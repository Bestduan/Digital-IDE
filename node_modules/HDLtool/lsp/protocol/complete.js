"use strict";

const vscode = require("vscode");
const parser = require("HDLparser");
const utils  = require("../utils/utils");

const ENT_BEGIN  = /\s*entity\s+(\w*)\s+is.*/;
const ARCH_BEGIN = /\s*architecture\s+(\w*)\s+of\s+(\w*)\s+is.*/;
const CONF_BEGIN = /\s*configuration\s+(\w*)\s+of\s+(\w*)\s+is.*/;
const SCOPE_END  = /\s*end\s+(\w*).*/;

let kwLibrary       = createCompletionKeyword('library');
let kwUse           = createCompletionKeyword('use');
let kwPackage       = createCompletionKeyword('package');
let kwArchitecture  = createCompletionKeyword('architecture');
let kwEntity        = createCompletionKeyword('entity');
let kwConfiguration = createCompletionKeyword('configuration');
let kwIs            = createCompletionKeyword('is');
let kwBegin         = createCompletionKeyword('begin');
let kwEnd           = createCompletionKeyword('end');
let kwMap           = createCompletionKeyword('map');
let kwOf            = createCompletionKeyword('of');
let kwFor           = createCompletionKeyword('for');

let operatorOptions = [
    createCompletionOption('abs'),
    createCompletionOption('and'),
    createCompletionOption('mod'),
    createCompletionOption('nand'),
    createCompletionOption('nor'),
    createCompletionOption('not'),
    createCompletionOption('or'),
    createCompletionOption('rem'),
    createCompletionOption('rol'),
    createCompletionOption('ror'),
    createCompletionOption('sla'),
    createCompletionOption('sll'),
    createCompletionOption('sra'),
    createCompletionOption('srl'),
    createCompletionOption('xnor'),
    createCompletionOption('xor'),
];
let archTypeOptions = [
    createCompletionOption('array'),
    createCompletionOption('type'),
    createCompletionOption('component'),
    createCompletionOption('constant'),
    createCompletionOption('signal'),
    createCompletionOption('subtype'),
    createCompletionOption('variable'),
    createCompletionOption('assert'),
    createCompletionOption('severity'),
    createCompletionOption('report'),
    createCompletionOption('process'),
    createCompletionOption('with'),
    createCompletionOption('select'),
    createCompletionOption('when'),
    createCompletionOption('others'),
    createCompletionOption('block'),
    createCompletionOption('function'),
    createCompletionOption('procedure'),
    createCompletionOption('case'),
    createCompletionOption('else'),
    createCompletionOption('elsif'),
    createCompletionOption('for'),
    createCompletionOption('generate'),
    createCompletionOption('if'),
    createCompletionOption('loop'),
    createCompletionOption('map'),
    createCompletionOption('next'),
    createCompletionOption('others'),
    createCompletionOption('return'),
    createCompletionOption('wait'),
    createCompletionOption('then'),
    createCompletionOption('return'),
    createCompletionOption('when'),
    createCompletionOption('while'),
];
let portTypeOptions = [
    createCompletionOption('in'),
    createCompletionOption('out'),
    createCompletionOption('inout'),
    createCompletionOption('buffer'),
    createCompletionOption('linkage'),
];
let entityOptions = [
    createCompletionOption('generic'),
    createCompletionOption('port'),
];
let scalaTypes = [
    createCompletionKeyword('bit', `The bit data type can only have the value 0 or 1.`),
    createCompletionKeyword('bit_vector', `The bit_vector data type is the vector version of the bit type consisting of two or more bits. Each bit in a bit_vector can only have the value 0 or 1.`),
    createCompletionKeyword('boolean', `True or false`),
    createCompletionKeyword('integer', `32-bit	integers.`),
    createCompletionKeyword('natural', `non	negative integer.`),
    createCompletionKeyword('positive', `positive	integer.`),
    createCompletionKeyword('real', `floating point number.`),
    createCompletionKeyword('time', `Time in fs,	ps,	ns,	us,	ms,	sec, min, hr`),
    createCompletionKeyword('character', ``),
    createCompletionKeyword('string', `String for VHDL.`),
    createCompletionOption('downto'),
    createCompletionOption('std_logic'),
];

(function (VhdlScopeKind) {
    VhdlScopeKind[VhdlScopeKind["Vhdl"] = 0] = "Vhdl";
    VhdlScopeKind[VhdlScopeKind["Entity"] = 1] = "Entity";
    VhdlScopeKind[VhdlScopeKind["Architecture"] = 2] = "Architecture";
    VhdlScopeKind[VhdlScopeKind["Configuration"] = 3] = "Configuration";
})(exports.VhdlScopeKind || (exports.VhdlScopeKind = {}));

function guessScope(doc, cursorLineNum) {
    return new ScopeGuesser(cursorLineNum).guess(doc);
}

class VhdlScope {
    constructor(kind, lineFrom) {
        this.kind = kind;
        this.children = [];
        this.lineFrom = lineFrom;
    }
    addChild(child) {
        this.children.push(child);
        child.parent = this;
    }
}

class ScopeGuesser {
    constructor(cursorLineNum) {
        this.cursorLineNum = cursorLineNum;
    }
    guess(doc) {
        this.enterScope(VhdlScopeKind.Vhdl, 0);
        for (var i = 0; i < doc.lineCount; i++) {
            var line = doc.lineAt(i);
            if (!line.isEmptyOrWhitespace) {
                let lineText = line.text;
                if (lineText.match(/^\s*\-\-/)) {
                    continue;
                }
                else if (lineText.match(ENT_BEGIN)) {
                    this.enterScope(VhdlScopeKind.Entity, i);
                }
                else if (lineText.match(ARCH_BEGIN)) {
                    this.enterScope(VhdlScopeKind.Architecture, i);
                }
                else if (lineText.match(CONF_BEGIN)) {
                    this.enterScope(VhdlScopeKind.Configuration, i);
                }
                else if (lineText.match(SCOPE_END)) {
                    this.exitScope(i);
                }
            }
        }
        this.exitScope(doc.lineCount);
        return this.scopeAtCursor;
    }
    enterScope(kind, lineNum) {
        let newScope = new VhdlScope(kind, lineNum);
        if (this.currentScope) {
            this.currentScope.addChild(newScope);
        }
        this.currentScope = newScope;
    }
    exitScope(lineNum) {
        this.currentScope.lineTo = lineNum;
        if (!this.scopeAtCursor) {
            if (this.currentScope.lineFrom <= this.cursorLineNum
                && this.currentScope.lineTo >= this.cursorLineNum) {
                this.scopeAtCursor = this.currentScope;
            }
        }
        if (this.currentScope.parent) {
            this.currentScope = this.currentScope.parent;
        }
    }
}

function createCompletionKeyword(label, doc) {
    let item = new vscode.CompletionItem(label);
    item.kind = vscode.CompletionItemKind.Keyword;
    if (doc) {
        item.documentation = doc;
    }
    return item;
}
function createCompletionOption(option, doc) {
    let item = new vscode.CompletionItem(option);
    item.kind = vscode.CompletionItemKind.Value;
    item.documentation = doc;
    return item;
}
class vhdlCompletion {

    constructor() {
        this.ENT_BEGIN  = /\s*entity\s+(\w*)\s+is.*/;
        this.ARCH_BEGIN = /\s*architecture\s+(\w*)\s+of\s+(\w*)\s+is.*/;
        this.CONF_BEGIN = /\s*configuration\s+(\w*)\s+of\s+(\w*)\s+is.*/;
        this.SCOPE_END  = /\s*end\s+(\w*).*/;

        this.Keyword = ['library','use','package','architecture','entity','configuration','is','begin','end','map','of','for'];

        this.ope = ['abs','and','mod','nand','nor','not','or','rem','rol','ror','sla','sll','sra','srl','xnor','xor'];


    }

    provideCompletionItems(document, position) {
        return new Promise((resolve, reject) => {
            let lineText = document.lineAt(position.line).text;
            if (lineText.match(/^\s*\-\-/)) {
                return resolve([]);
            }
            let inString = false;
            if ((lineText.substring(0, position.character).match(/\"/g) || []).length % 2 === 1) {
                inString = true;
            }
            let suggestions = [];
            let textBeforeCursor = lineText.substring(0, position.character - 1);
            let scope = guessScope(document, position.line);
            switch (scope.kind) {
                case VhdlScopeKind.Vhdl: {
                    suggestions.push(kwArchitecture);
                    suggestions.push(kwBegin);
                    suggestions.push(kwConfiguration);
                    suggestions.push(kwEnd);
                    suggestions.push(kwEntity);
                    suggestions.push(kwIs);
                    suggestions.push(kwPackage);
                    suggestions.push(kwUse);
                    suggestions.push(kwLibrary);
                    break;
                }
                case VhdlScopeKind.Entity: {
                    if (textBeforeCursor.match(/^\s*\w*$/)) {
                        suggestions.push(...entityOptions);
                        suggestions.push(...portTypeOptions);
                        suggestions.push(kwBegin);
                        suggestions.push(kwEnd);
                    }
                    else if (textBeforeCursor.match(/(in|out|inout|buffer|linkage)\s*$/)) {
                        suggestions.push(...scalaTypes);
                    }
                    break;
                }
                case VhdlScopeKind.Architecture: {
                    if (textBeforeCursor.match(/^\s*\w*$/)) {
                        suggestions.push(...archTypeOptions);
                        suggestions.push(kwBegin);
                        suggestions.push(kwEnd);
                        suggestions.push(kwIs);
                        suggestions.push(kwOf);
                    }
                    else if (textBeforeCursor.match(/(in|out|inout|buffer|linkage)\s*$/)) {
                        suggestions.push(...scalaTypes);
                    }
                    else if (textBeforeCursor.match(/(signal|variable|constant|subtype|type|array)\s*\w*:\s*$/)) {
                        suggestions.push(...scalaTypes);
                    }
                    else if (textBeforeCursor.match(/(<=|:=)\s*\w*\s*$/)) {
                        suggestions.push(...operatorOptions);
                    }
                    break;
                }
                case VhdlScopeKind.Configuration: {
                    suggestions.push(kwFor);
                    break;
                }
            }
            return resolve(suggestions);
        });
    }

    createCompletionItem(label, doc, kind) {
        let item = new vscode.CompletionItem(label);
        item.kind = kind;
        if (doc) {
            item.documentation = doc;
        }
        return item;
    }

    
}
exports.vhdlCompletion = vhdlCompletion;


class vlogCompletion {
    constructor(indexer){
        this.indexer = indexer;
        this.parse = new parser.vlogParser();
    }

    provideCompletionItems(document, position) {
        return new Promise((resolve, reject) => {
            // 初试化
            let text = document.getText(); 
            let path = document.uri.fsPath.replace(/\\/g, "\/"); // 标识字符所在文件的路径
            let guide_index = utils.position_to_index(text, position) - 1;
            let guide = text[guide_index];
            let guideRange = {
                "start" : position,
                "end"  : position,
            };

            utils.HDLparam = this.indexer.HDLparam;

            // 合法性
            // 获取注释所对应的范围，并检测标识字符是否在该范围内
            // let illegalRange = this.parse.get_comment_index(text);
            // for (let index = 0; index < illegalRange.length; index++) {
            //     const range = illegalRange[index];
            //     if (utils.ensureInclude(range, guideRange)) {
            //         resolve([]);
            //     }
            // }

            switch (guide) {
                case '.' :
                    let item = this.getInstance(text, guideRange);
                    let defines = utils.getInstDefine(guideRange, item);
                    resolve(this.symbols_to_items(defines, item.instModPath));
                break;

                case '`' :
                    resolve(this.getDefine(text, path));
                break;
            
                default: reject(); break;
            }
        });
    }

    getDefine(text, path) {
        let defines = new Map();
        this.parse.get_define(text, path, defines);

        let items = []
        defines.forEach((value, key) => {
            let item = new vscode.CompletionItem(
                key,
                vscode.CompletionItemKind.Keyword,
            );
            item.detail = value;
            items.push(item);
        });

        return items;
    }

    /**
     * @descriptionCn 获取需要提示的地方在该文件下的哪个例化模块中
     * @param {String} path 当前文件的路径
     * @param {Object} wordRange 需要提示的标识所对应的范围
     * @returns {Object} 返回需要提示的地方所在的例化模块的全部属性
     */
    getInstance(text, wordRange) {
        let instances = this.parse.get_instances(text);

        for (let index = 0; index < instances.length; index++) {
            const instance = instances[index];
            const instRange = utils.index_to_range(text, instance);
            if (!utils.ensureInclude(instRange, wordRange)) {
                continue;
            }
            instance.instports = utils.index_to_range(text, instance.instports);
            instance.instparams = utils.index_to_range(text, instance.instparams);
            return instance;
        }
    }

    /**
     * @descriptionCn 将被定义部分的属性内容转换成CompletionItem
     * @param {*} defines 被定义部分的属性
     * @param {*} detail  定义描述的细节
     * @returns {Array} 返回转换成的CompletionItem项
     */
    symbols_to_items(defines, detail){
        let items = [];
        for (let index = 0; index < defines.length; index++) {
            const define = defines[index];
            let item = new vscode.CompletionItem(
                define.name,
                vscode.CompletionItemKind.Interface,
            );
            // item.tags   = module.moduleName;
            item.detail = detail;
            items.push(item);
        }
        return items;
    }
}
exports.vlogCompletion = vlogCompletion;

class jsonCompletion {
    constructor () {
        this.Apply = ["DSP", "Image"];
        this.DSP   = ["Advance", "Base"];
        this.Advance     = ["Communicate"];
        this.Communicate = ["Demodulate", "Modulate"];
        this.Demodulate  = ["IQ"];
        this.Modulate    = ["AM", "FM"];

        this.Base  = ["CLK", "DDS"];

        this.Math  = ["Cordic.v", "Sort3.v"];
        this.Soc   = ["Cortex_M0", "Cortex_M3"];
    }
    provideCompletionItems(document, position, token) {
        return new Promise((resolve, reject) => {
            let suggestions = [];
            let lineText = document.lineAt(position.line).text.match(/(\w+\/+)+/g);
            let element  = lineText[0].split("/");
            switch (element[element.length - 2]) {
                case "Apply": this.createCompletionItem(this.Apply,suggestions); break;
                case "DSP": this.createCompletionItem(this.DSP,suggestions); break;
                case "Advance": this.createCompletionItem(this.Advance,suggestions); break;
                case "Communicate": this.createCompletionItem(this.Communicate,suggestions); break;
                case "Demodulate": this.createCompletionItem(this.Demodulate,suggestions); break;
                case "Modulate": this.createCompletionItem(this.Modulate,suggestions); break;
                case "Base": this.createCompletionItem(this.Base,suggestions); break;
                case "Math": this.createCompletionItem(this.Math,suggestions); break;
                case "Soc": this.createCompletionItem(this.Soc,suggestions); break;
                default: break;
            }
            return resolve(suggestions);
        });
    }
    createCompletionItem(List, suggestions) {
        for (let i = 0; i < List.length; i++) {
            const element = List[i];
            let item = new vscode.CompletionItem(element);
            item.kind = vscode.CompletionItemKind.Keyword;
            suggestions.push(item);
        }
    }
}
exports.jsonCompletion = jsonCompletion;