"use strict";

const vscode = require("vscode");
const parser = require("HDLparser");
const utils  = require("../utils/utils");

class vhdlCompletion {

    constructor() {
        
    }

    provideCompletionItems(document, position) {
        return new Promise((resolve, reject) => {
            
        });
    }
}
exports.vhdlCompletion = vhdlCompletion;


class vlogCompletion {
    constructor(indexer){
        this.indexer = indexer;
        this.parse = new parser.vlogParser();
        this.funcs = [
            { key : "display()", description : ""},
            { key : "write()", description : ""},
            { key : "strobe()", description : ""},
            { key : "monitor()", description : ""},

            { key : "fopen()", description : ""},
            { key : "fclose()", description : ""},
            { key : "ferror()", description : ""},

            { key : "fdisplay()", description : ""},
            { key : "fwrite()", description : ""},
            { key : "fstrobe()", description : ""},
            { key : "fmonitor()", description : ""},

            { key : "sformat()", description : ""},
            { key : "swrite()", description : ""},

            { key : "fgetc()", description : ""},
            { key : "fgets()", description : ""},

            { key : "fscanf()", description : ""},
            { key : "fread()", description : ""},

            { key : "readmemh()", description : ""},
            { key : "readmemb()", description : ""},

            { key : "clog2()", description : ""},
            { key : "log10()", description : ""},
            { key : "ln()", description : ""},

            { key : "exp()", description : ""},
            { key : "sqrt()", description : ""},
            { key : "pow()", description : ""},

            { key : "sin()", description : ""},
            { key : "cos()", description : ""},
            { key : "tan()", description : ""},

            { key : "sinh()", description : ""},
            { key : "cosh()", description : ""},
            { key : "tanh()", description : ""},

            { key : "asinh()", description : ""},
            { key : "acosh()", description : ""},
            { key : "atanh()", description : ""},

            { key : "asin()", description : ""},
            { key : "acos()", description : ""},
            { key : "acos()", description : ""},

            { key : "finish()", description : ""},
            { key : "stop()", description : ""},

            { key : "random()", description : ""},
            
            { key : "signed()", description : ""},
            { key : "unsigned()", description : ""},
        ]
    }

    provideCompletionItems(document, position) {
        return new Promise((resolve, reject) => {
            // 初试化
            let text = document.getText(); 
            let path = document.uri.fsPath.replace(/\\/g, "\/"); // 标识字符所在文件的路径
            let guide_index = utils.position_to_index(text, position) - 1;
            let guide = text[guide_index];
            let guideRange = {
                "start" : position,
                "end"  : position,
            };

            utils.HDLparam = this.indexer.HDLparam;

            // 合法性
            // 获取注释所对应的范围，并检测标识字符是否在该范围内
            // let illegalRange = this.parse.get_comment_index(text);
            // for (let index = 0; index < illegalRange.length; index++) {
            //     const range = illegalRange[index];
            //     if (utils.ensureInclude(range, guideRange)) {
            //         resolve([]);
            //     }
            // }

            switch (guide) {
                case '.' :
                    let item = this.getInstance(text, guideRange);
                    let defines = utils.getInstDefine(guideRange, item);
                    resolve(this.symbols_to_items(defines, item.instModPath));
                break;

                case '`' :
                    resolve(this.getDefine(text, path));
                break;

                case '$' :
                    resolve(this.getFunction());
                break;
            
                default: reject(); break;
            }
        });
    }

    getFunction() {
        let items = []
        this.funcs.forEach((element) => {
            let item = new vscode.CompletionItem(
                element.key,
                vscode.CompletionItemKind.Function,
            );
            item.detail = element.description;
            items.push(item);
        });

        return items;
    }

    getDefine(text, path) {
        let defines = new Map();
        this.parse.get_define(text, path, defines);

        let items = []
        defines.forEach((value, key) => {
            let item = new vscode.CompletionItem(
                key,
                vscode.CompletionItemKind.Field,
            );
            item.detail = value;
            items.push(item);
        });

        return items;
    }

    /**
     * @descriptionCn 获取需要提示的地方在该文件下的哪个例化模块中
     * @param {String} path 当前文件的路径
     * @param {Object} wordRange 需要提示的标识所对应的范围
     * @returns {Object} 返回需要提示的地方所在的例化模块的全部属性
     */
    getInstance(text, wordRange) {
        let instances = this.parse.get_instances(text);

        for (let index = 0; index < instances.length; index++) {
            const instance = instances[index];
            const instRange = utils.index_to_range(text, instance);
            if (!utils.ensureInclude(instRange, wordRange)) {
                continue;
            }
            instance.instports = utils.index_to_range(text, instance.instports);
            instance.instparams = utils.index_to_range(text, instance.instparams);
            return instance;
        }
    }

    /**
     * @descriptionCn 将被定义部分的属性内容转换成CompletionItem
     * @param {*} defines 被定义部分的属性
     * @param {*} detail  定义描述的细节
     * @returns {Array} 返回转换成的CompletionItem项
     */
    symbols_to_items(defines, detail){
        let items = [];
        for (let index = 0; index < defines.length; index++) {
            const define = defines[index];
            let item = new vscode.CompletionItem(
                define.name,
                vscode.CompletionItemKind.Interface,
            );
            // item.tags = module.moduleName;
            item.detail = detail;
            items.push(item);
        }
        return items;
    }
}
exports.vlogCompletion = vlogCompletion;

class jsonCompletion {
    constructor () {
        this.Apply = ["DSP", "Image"];
        this.DSP   = ["Advance", "Base"];
        this.Advance     = ["Communicate"];
        this.Communicate = ["Demodulate", "Modulate"];
        this.Demodulate  = ["IQ"];
        this.Modulate    = ["AM", "FM"];

        this.Base  = ["CLK", "DDS"];

        this.Math  = ["Cordic.v", "Sort3.v"];
        this.Soc   = ["Cortex_M0", "Cortex_M3"];
    }
    provideCompletionItems(document, position, token) {
        return new Promise((resolve, reject) => {
            let suggestions = [];
            let lineText = document.lineAt(position.line).text.match(/(\w+\/+)+/g);
            let element  = lineText[0].split("/");
            switch (element[element.length - 2]) {
                case "Apply": this.createCompletionItem(this.Apply,suggestions); break;
                case "DSP": this.createCompletionItem(this.DSP,suggestions); break;
                case "Advance": this.createCompletionItem(this.Advance,suggestions); break;
                case "Communicate": this.createCompletionItem(this.Communicate,suggestions); break;
                case "Demodulate": this.createCompletionItem(this.Demodulate,suggestions); break;
                case "Modulate": this.createCompletionItem(this.Modulate,suggestions); break;
                case "Base": this.createCompletionItem(this.Base,suggestions); break;
                case "Math": this.createCompletionItem(this.Math,suggestions); break;
                case "Soc": this.createCompletionItem(this.Soc,suggestions); break;
                default: break;
            }
            return resolve(suggestions);
        });
    }
    createCompletionItem(List, suggestions) {
        for (let i = 0; i < List.length; i++) {
            const element = List[i];
            let item = new vscode.CompletionItem(element);
            item.kind = vscode.CompletionItemKind.Keyword;
            suggestions.push(item);
        }
    }
}
exports.jsonCompletion = jsonCompletion;