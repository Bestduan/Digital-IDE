"use strict";

const fs = require("fs");
const vscode = require("vscode");
const parser = require("HDLparser");

/* 语言服务功能 */

/* Symbol */

var symbol = {

    symbols : null,

    curdoc : null,

    /**
     * @state finish - untest
     * @descriptionEn set a symbol information object.
     * @param  symbol The name of the symbol.
     * @param  parent The name of the symbol containing the symbol.
     * @return The object of the SymbolInformation.
     */
    setSymbolInfo : function (symbol){
        let location = new vscode.Location(
            this.curdoc.uri, 
            new vscode.Range(
                this.curdoc.positionAt(symbol.startIndex), 
                this.curdoc.positionAt(symbol.lastIndex)
            )
        );

        let symbolInfo =  vscode.SymbolInformation(
            symbol.name,
            this.getSymbolKind(symbol.type),
            symbol.parent,
            location
        );

        this.symbols.push(symbolInfo);
    },

    /**
     * @state finish - untest
     * @descriptionEn get a symbol Kind.
     * @param name The name of the symbol.
     * @return     The SymbolKind of the symbol's name.
     */
    getSymbolKind : function (name) {
        if (name.indexOf('[') != -1) {
            return vscode.SymbolKind.Array;
        }
        switch (name) {
            case 'module':      return vscode.SymbolKind.Module;
            case 'program':     return vscode.SymbolKind.Module;
            case 'package':     return vscode.SymbolKind.Package;
            case 'import':      return vscode.SymbolKind.Package;
            case 'always':      return vscode.SymbolKind.Operator;
            case 'processe':    return vscode.SymbolKind.Operator;
    
            case 'task':        return vscode.SymbolKind.Method;
            case 'function':    return vscode.SymbolKind.Function;
    
            case 'assert':      return vscode.SymbolKind.Boolean;
            case 'event':       return vscode.SymbolKind.Event;
            case 'instance':    return vscode.SymbolKind.Event;
    
            case 'time':        return vscode.SymbolKind.TypeParameter;
            case 'define':      return vscode.SymbolKind.TypeParameter;
            case 'typedef':     return vscode.SymbolKind.TypeParameter;
            case 'generate':    return vscode.SymbolKind.Operator;
            case 'enum':        return vscode.SymbolKind.Enum;
            case 'modport':     return vscode.SymbolKind.Boolean;
            case 'property':    return vscode.SymbolKind.Property;

            // port 
            case 'interface':   return vscode.SymbolKind.Interface;
            case 'buffer':      return vscode.SymbolKind.Interface;
            case 'output':      return vscode.SymbolKind.Interface;
            case 'input':       return vscode.SymbolKind.Interface;
            case 'inout':       return vscode.SymbolKind.Interface;

            // synth param    
            case 'localparam':  return vscode.SymbolKind.Constant;
            case 'parameter':   return vscode.SymbolKind.Constant;
            case 'integer':     return vscode.SymbolKind.Number;
            case 'char':        return vscode.SymbolKind.Number;
            case 'float':       return vscode.SymbolKind.Number;
            case 'int':         return vscode.SymbolKind.Number;

            // unsynth param
            case 'string':      return vscode.SymbolKind.String;
            case 'struct':      return vscode.SymbolKind.Struct;
            case 'class':       return vscode.SymbolKind.Class;
            
            case 'logic':       return vscode.SymbolKind.Constant;
            case 'wire':        return vscode.SymbolKind.Constant;
            case 'reg':         return vscode.SymbolKind.Constant;
            case 'bit':         return vscode.SymbolKind.Boolean;
            default:            return vscode.SymbolKind.Field;
        }
        /* Unused/Free SymbolKind icons
            return SymbolKind.Number;
            return SymbolKind.Enum;
            return SymbolKind.EnumMember;
            return SymbolKind.Operator;
            return SymbolKind.Array;
        */
    },

    range_to_index : function (text, range) {
        let startIndex = 0;
        let lastIndex  = 0;
        let lines = text.split('\n');
        for (let i = 0; i < range.start.line; ++i) {
            startIndex = startIndex + lines[i].length + 1;
        }
        startIndex = startIndex + range.start.character;
        for (let i = 0; i < range.end.line; ++i) {
            lastIndex = lastIndex + lines[i].length + 1;
        }
        lastIndex = lastIndex + range.end.character;
        return {
            "startIndex" : startIndex,
            "lastIndex"  : lastIndex,
        }
    },

    index_to_range : function (text, index) {
        
    }
}

// 悬停提示
class HoverProvider {
    provideHover(document, position, token) {
        return new Promise((resolve, reject) => {
            var lookupRange = document.getWordRangeAtPosition(position);
            if (!lookupRange) {
                return resolve(undefined);
            }
            let defination = vscode.commands.executeCommand("vscode.executeDefinitionProvider", document.uri, position, token);
            resolve(defination.then(async (loc) => {
                const doc = await vscode.workspace.openTextDocument(loc[0].uri);
                let content = doc.lineAt(loc[0].range.start.line).text;
                if (String.prototype.trim) {
                    content = content.trim();
                } else {
                    content = content.replace(/^\s+(.*?)\s+$/g, "$1");
                }
                content = this.del_spacing(content, 4);
                content = content.replace(/\/\//g, "\n//") + "\n" + this.get_comment(doc, loc[0].range.start.line - 1);
                return content;
            }).then((str) => {
                return new vscode.Hover( { language: 'systemverilog', value: str } );
            }));
        });
    }
    
    get_comment(doc, line) {
        if (line < 0) {
            return "";
        }
        let comment = "";
        let commentList = [];
        let content = doc.lineAt(line).text;
        let isblank   = content.match(/\S+/g);
        let l_comment = content.match(/(?<!(\s*\w+\s*))(\/\/.*)/g);
        let b_comment = content.match(/.*\*\//g);
        while (1) {
            if ( l_comment == null && b_comment == null && isblank != null) {
                break;
            } else {
                if ( isblank != null ) {                    
                    if (l_comment != null) {
                        commentList.push(l_comment + "\n");
                    } else {
                        commentList.push(b_comment + "\n");
                        while (1) {
                            line = line - 1;
                            content = doc.lineAt(line).text;
                            b_comment = content.match(/\/\*.*/g);
                            if (b_comment != null || line == 0) {
                                commentList.push(b_comment + "\n");
                                break;
                            }
                            commentList.push(content + "\n");
                        }
                    }
                }
                line = line - 1;
                if (line == -1) {
                    break;
                }
                content = doc.lineAt(line).text;
                isblank   = content.match(/\S+/g);
                l_comment = content.match(/(?<!(\s*\w+\s*))(\/\/.*)/g);
                b_comment = content.match(/.*\*\//g);
            }
        }
        for (let index = (commentList.length - 1); index >= 0; index--) {
            comment = comment + commentList[index];
        }
        return comment;
    }

    del_spacing(content, spacingNum) {
        let newContent = '';
        let i = 0;
        for (let index = 0; index < content.length; index++) {
            const element = content[index];
            if (element == ' ') {
                i++;
            }
            if (((element != ' ') && (element != '\t')) || (i <= spacingNum)) {
                newContent = newContent + element;
                if (i > spacingNum) {
                    i = 0;
                }
            }
        }
        return newContent;
    }

    vhdl_hover(document, position, token) {
        let wordRange = document.getWordRangeAtPosition(position, /\w[-\w\.\"]*/g);
        if (wordRange !== undefined) {
            let leadingText = document.getText(new vscode.Range(wordRange.start, wordRange.end));
            if (/x"[0-9a-fA-F_]+"/g.test(leadingText)) {
                const regex = /x"([0-9a-fA-F_]+)"/g;
                let number = regex.exec(leadingText.replace('_', ''));
                if (number === null || number[1] === null) {
                    return;
                }
                let x = parseInt(number[1], 16);
                let x1 = this.eval_signed_hex(number[1], x);
                if (x === x1) {
                    return new vscode.Hover(leadingText + ' = ' + x);
                }
                else {
                    return new vscode.Hover(leadingText + ' = ' + x + ' (unsigned)  || ' + x1 + ' (signed)');
                }
            }
            else if (/[0-1_]+"/g.test(leadingText)) {
                const regex = /([0-1_]+)"/g;
                let number = regex.exec(leadingText.replace('_', ''));
                if (number === null || number[1] === null) {
                    return;
                }
                let x = parseInt(number[0], 2);
                let x1 = this.eval_signed_bin(number[0], x);
                if (x === x1) {
                    return new vscode.Hover('"' + leadingText + ' = ' + x);
                }
                else {
                    return new vscode.Hover('"' + leadingText + ' = ' + x + ' (unsigned) || ' + x1 + ' (signed)');
                }
            }
        }
    }
    
    verilog_hover(document, position, token) {
        let wordRange = document.getWordRangeAtPosition(position, /\w[-\w\.\']*/g);
        if (wordRange !== undefined) {
            let leadingText = document.getText(new vscode.Range(wordRange.start, wordRange.end));
            if (/[0-9]+?'h[0-9a-fA-F_]+/g.test(leadingText)) {
                const regex = /[0-9]+?'h([0-9a-fA-F_]+)/g;
                let number = regex.exec(leadingText.replace('_', ''));
                if (number === null || number[1] === null) {
                    return;
                }
                let x = parseInt(number[1], 16);
                let x1 = this.eval_signed_hex(number[1], x);
                if (x === x1) {
                    return new vscode.Hover(leadingText + ' = ' + x);
                }
                else {
                    return new vscode.Hover(leadingText + ' = ' + x + ' (unsigned) || ' + x1 + ' (signed)');
                }
            }
            else if (/[0-9]+?'b[0-1_]+/g.test(leadingText)) {
                const regex = /[0-9]+?'b([0-1_]+)/g;
                let number = regex.exec(leadingText.replace('_', ''));
                if (number === null || number[1] === null) {
                    return;
                }
                let x = parseInt(number[1], 2);
                let x1 = this.eval_signed_bin(number[1], x);
                if (x === x1) {
                    return new vscode.Hover(leadingText + ' = ' + x);
                }
                else {
                    return new vscode.Hover(leadingText + ' = ' + x + ' (unsigned) || ' + x1 + ' (signed)');
                }
            }
            else if (/[0-9]+?'o[0-8_]+/g.test(leadingText)) {
                const regex = /[0-9]+?'o([0-7_]+)/g;
                let number = regex.exec(leadingText.replace('_', ''));
                if (number === null || number[1] === null) {
                    return;
                }
                let x = parseInt(number[1], 8);
                let x1 = this.eval_signed_oct(number[1], x);
                if (x === x1) {
                    return new vscode.Hover(leadingText + ' = ' + x);
                }
                else {
                    return new vscode.Hover(leadingText + ' = ' + x + ' (unsigned) || ' + x1 + ' (signed)');
                }
            }
        }
    }

    eval_signed_hex(number_s, int_number) {
        let pow_hex = Math.pow(16, number_s.length);
        let x1 = int_number;
        if (int_number >= pow_hex >> 1) {
            x1 = int_number - pow_hex;
        }
        return x1;
    }

    eval_signed_bin(number_s, int_number) {
        let pow_bin = 1 << number_s.length - 1;
        let x1 = int_number;
        if (int_number >= pow_bin >> 1) {
            x1 = int_number - pow_bin;
        }
        return x1;
    }

    eval_signed_oct(number_s, int_number) {
        let pow_oct = Math.pow(8, number_s.length);
        let x1 = int_number;
        if (int_number >= pow_oct >> 1) {
            x1 = int_number - pow_oct;
        }
        return x1;
    }
}
exports.HoverProvider = HoverProvider;

// 定义跳转
class DefinitionProvider {
    constructor(indexer) {
        this.indexer = indexer;
        this.parse = null;
    };
    provideDefinition(document, position, token) {
        return new Promise((resolve, reject) => {
            let results = [];
            let range = document.getWordRangeAtPosition(position);
            let word  = document.getText(range);
            let path  = document.uri.fsPath.replace(/\\/g, "\/");
            let text  = document.getText();
            let symbolRange = this.range_to_index(text, range);
            if (document.languageId == "verilog" || document.languageId == "systemverilog") {
                this.parse = parser.vlogParser;
            }
            else if (document.languageId == "vhdl" ) {
                this.parse = parser.vhdlParser;
            } else {
                reject();
                return;
            }
            let IllegalRange = this.parse.getCommentRange(text,0);
            if (parser.utils.isIllegalRange(symbolRange, IllegalRange)) {
                resolve(results);
            }
            if (!range) {
                reject();
            }
            text = this.parse.delComments(text);
            let symbols = this.indexer.symbols.get(path);
            if (symbols == undefined) {
                symbols = this.indexer.getFileParam(document, this.indexer.HDLSymbol, "symbol");
            }
            let Symbol = {
                "word" : word,
                "startIndex" : symbolRange.startIndex,
                "lastIndex"  : symbolRange.lastIndex,
            }
            let newCharacter = (range.start.character == 0) ? 0 : range.start.character - 1;
            let newStart = new vscode.Position(range.start.line, newCharacter);
            let newRange = new vscode.Range(newStart, range.start)
            let flage  = document.getText(newRange);

            // Check for instance symbols
            if (flage == '.') {
                this.getInstanceSymbol(text, Symbol, results, "property");
                resolve(results);
            } else {
                // Check for local symbols
                for (let index = 0; index < symbols.length; index++) {
                    const symbolElement = symbols[index];
                    if (symbolElement.name == word) {
                        let moduleRange    = this.getCurrentModuleRange(text, symbolRange);
                        let defsymbolRange = this.range_to_index(text, symbolElement.location.range);
                        if (this.ensureInclude(moduleRange, defsymbolRange)) {
                            let result = {
                                uri : symbolElement.location.uri,
                                range : symbolElement.location.range,
                            }
                            results.push(result);
                        }
                    }
                }
                this.getInstanceSymbol(text, Symbol, results, "name");
                resolve(results);
            }
        });
    }
    range_to_index(content, Range) {
        let startIndex = 0;
        let lastIndex  = 0;
        let lines = content.split('\n');
        for (let i = 0; i < Range.start.line; ++i) {
            startIndex = startIndex + lines[i].length + 1;
        }
        startIndex = startIndex + Range.start.character;
        for (let i = 0; i < Range.end.line; ++i) {
            lastIndex = lastIndex + lines[i].length + 1;
        }
        lastIndex = lastIndex + Range.end.character;
        return {
            "startIndex" : startIndex,
            "lastIndex"  : lastIndex,
        }
    }
    findModuleFromPath (HDLparam, path) {
        let moduleInfo = [];
        for (let index = 0; index < HDLparam.length; index++) {
            const unitMoudule = HDLparam[index];
            if (unitMoudule.modulePath == path) {
                moduleInfo.push(unitMoudule);
            }
        }
        return moduleInfo;
    }
    findModuleFromName (HDLparam, name) {
        let moduleInfo = [];
        for (let index = 0; index < HDLparam.length; index++) {
            const unitMoudule = HDLparam[index];
            if (unitMoudule.moduleName == name) {
                moduleInfo.push(unitMoudule);
            }
        }
        return moduleInfo;
    }
    getCurrentModuleRange(text, symbolRange) {
        while (1) {
            let match = this.parse.vlogRegExp.module.exec(text);
            if (match == null) {
                break;      
            }
            let range = {
                "startIndex": match.index,
                "lastIndex" : match.index + match[0].length,
            };
            if (this.ensureInclude(range, symbolRange)) {
                return range;
            }
        }
    }
    getInstanceSymbol(text, Symbol, results, mode) {
        let instances = this.parse.get_instances(text, null, null, 0, null);
        for (let index = 0; index < instances.length; index++) {
            const instance = instances[index];
            if (this.ensureInclude(instance, Symbol)) {
                let modules = this.findModuleFromName(this.indexer.HDLparam, instance.instModule);
                for (let i = 0; i < modules.length; i++) {
                    let module  = modules[i];
                    let symbols = this.indexer.symbols.get(module.modulePath);
                    let content = fs.readFileSync(module.modulePath, "utf-8");
                    for (let x = 0; x < symbols.length; x++) {
                        const symbolElement = symbols[x];
                        const symbolRange = this.range_to_index(content, symbolElement.location.range);
                        if (symbolElement.name == Symbol.word && this.ensureInclude(module, symbolRange)) {
                            if (mode == "name" && Symbol.word == instance.instModule) {
                                let result = {
                                    uri : symbolElement.location.uri,
                                    range : symbolElement.location.range,
                                }
                                results.push(result);
                                break;
                            }
                            else if (mode == "property") {
                                let result = {
                                    uri : symbolElement.location.uri,
                                    range : symbolElement.location.range,
                                }
                                results.push(result);
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
    ensureInclude(parent, child) {
        if (parent.startIndex <= child.startIndex && 
            parent.lastIndex  >= child.lastIndex) {
            return true;
        }
        return false;
    }
}
exports.DefinitionProvider = DefinitionProvider;

// 文件标志
class DocumentSymbolProvider {
    constructor(indexer) {
        this.indexer = indexer;
    }
    /**
        Matches the regex pattern with the document's text. If a match is found, it creates a `Symbol` object.
        If `documentSymbols` is not `undefined`, than the object is added to it,
        otherwise add the objects to an empty list and return it.
        
        @param document The document in which the command was invoked.
        @param token A cancellation token.
        @return A list of `Symbol` objects or a thenable that resolves to such. The lack of a result can be
        signaled by returning `undefined`, `null`, or an empty list.
    */
    provideDocumentSymbols(document, token) {
        return new Promise((resolve) => {
            let symbols = this.indexer.symbols.get(document.uri.fsPath);
            if (symbols == undefined) {
                symbols = this.indexer.getFileParam(document, this.indexer.HDLSymbol, "symbol");
            }
            resolve(symbols);
        });
    }
}
exports.DocumentSymbolProvider = DocumentSymbolProvider;

// 工作区标志
class WorkspaceSymbolProvider {
    constructor(indexer) {
        this.indexer = indexer;
    };
    /**
        Queries a symbol from `this.symbols`, performs an exact match if `exactMatch` is set to true,
        and a partial match if it's not passed or set to false.

        @param query the symbol's name
        @param token the CancellationToken
        @param exactMatch whether to perform an exact or a partial match
        @return an array of matching Symbol
    */
    provideWorkspaceSymbols(query, token, exactMatch) {
        return new Promise((resolve, reject) => {
            if (query.length === 0) {
                resolve([]);
            } else {
                const pattern = new RegExp(".*" + query.replace(" ", "").split("").map((c) => c).join(".*") + ".*", 'i');
                let results = new Array();
                for (let index = 0; index < this.indexer.symbols.length; index++) {
                    const list = this.indexer.symbols[index];
                    for (let index = 0; index < list.length; index++) {
                        const symbol = list[index];
                        if (exactMatch === true) {
                            if (symbol.name == query) {
                                results.push(symbol);
                            }
                        }
                        else if (symbol.name.match(pattern)) {
                            results.push(symbol);
                        }
                    }
                }
                resolve(results);
            }
        });
    }
    /**
        Queries a `module` with a given name from `this.symbols`, performs an exact match if `exactMatch` is set to true,
        and a partial match if it's not passed or set to false.
        @param query the symbol's name
        @return the module's Symbol
    */
    provideWorkspaceModule(query) {
        if (query.length === 0) {
            return undefined;
        }
        else {
            let symbolInfo = undefined;
            this.indexer.symbols.forEach(list => {
                list.forEach(symbol => {
                    if (symbol.name == query && symbol.kind == this.indexer.HDLSymbol.getSymbolKind("module")) {
                        symbolInfo = symbol;
                        return false;
                    }
                });
                if (symbolInfo) {
                    return false;
                }
            });
            return symbolInfo;
        }
    }
}
exports.WorkspaceSymbolProvider = WorkspaceSymbolProvider;
