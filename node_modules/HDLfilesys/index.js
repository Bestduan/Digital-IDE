"use strict";

const fs = require("fs");
const fspath = require("path");
const vscode = require("vscode");
const chokidar = require("chokidar");

const dirs  = require("./operation/dirs");
const files = require("./operation/files");
const paths = require("./operation/path");

exports.dirs  = dirs;
exports.files = files;
exports.paths = paths;

/**
 * the class of HDL file process
 * 
 */
class processPrjFiles {
    constructor(indexer) {
        this.opeParam = {
            "os"             : "",
            "rootPath"       : "",
            "workspacePath"  : "",
            "prjInfo"        : null,
            "srcTopModule"   : {
                name: '',
                path: ''
            },
            "simTopModule"   : {
                name: '',
                path: ''
            },
            "prjStructure" : {
                "prjPath" : "",
                "HardwareSim"  : "",
                "HardwareSrc"  : "",
                "HardwareData" : "",
                "SoftwareSrc"  : "",
                "SoftwareData" : ""
            },
            "currentHDLPath" : [],
            "prjInitParam"   : "",
            "propertyPath"   : ""
        };
        this.indexer  = indexer;
        this.terminal = null;
        this.treeView = null;
        this.hardware = null;
        
        this.setting = vscode.workspace.getConfiguration();
        this.log  = vscode.window.showInformationMessage;
        this.err  = vscode.window.showErrorMessage;
        this.warn = vscode.window.showWarningMessage;
        // All are represented in the form of library paths and no workspace paths
        this.oldLibFileList = [];
        this.newLibFileList = []; // 路径形式全为扩展硬件库所在的路径

        vscode.commands.registerCommand('TOOL.Gen_Property', () => {
            this.generatePropertyFile();
        });
        vscode.commands.registerCommand('TOOL.Overwrite_InitProperty', () => {
            this.overwriteInitProperty();
        });
    }

    /**
     * CN: 预处理部分，获取当前系统参数以及工程配置文件
     * @param {*} currentDirName 扩展所在的根目录
     * @param {*} opeParam 全局操作参数
     * @returns 
     */
    getOpeParam(currentDirName) {
        // 获取当前工作区路径
        if (vscode.workspace.workspaceFolders != undefined &&
            vscode.workspace.workspaceFolders.length != 0) {
            this.opeParam.workspacePath = vscode.workspace.workspaceFolders[0].uri.fsPath;
        } else {
            this.opeParam.workspacePath = '';
            return false; 
        }
        this.opeParam.workspacePath = this.opeParam.workspacePath.replace(/\\/g, "\/");

        // 获取当前平台运行的系统
        this.opeParam.os = process.platform;

        // 获取当前根路径
        this.opeParam.rootPath = currentDirName.replace(/\\/g, "\/");

        // 获取初始配置文件的路径
        this.opeParam.prjInitParam = `${this.opeParam.rootPath}/prjInitParam.json`;
        
        // 初始化工程参数与信息
        this.getPropertyInfo();

        return true;
    }

    /**
     * CN: 获取工程配置参数 (不对参数内容做深度处理)
     * @returns false: 不存在工程配置文件 true: 成功获取工程的配置参数
     */
    getPropertyInfo() {
        // CN: 初始化基本参数
        this.opeParam.prjInfo = null;
        this.opeParam.propertyPath = `${this.opeParam.workspacePath}/.vscode/property.json`;

        // CN: 获取正确的工程配置文件路径，如果配置文件不存在则直接退出
        if (!fs.existsSync(this.opeParam.propertyPath)) {
            if (fs.existsSync(`${this.opeParam.workspacePath}/property.json`)) {
                this.opeParam.propertyPath = `${this.opeParam.workspacePath}/property.json`;
            } else {
                this.opeParam.propertyPath = "";
                this.opeParam.prjStructure.HardwareSrc = this.opeParam.workspacePath;
                return false;
            }
        }

        // CN: 获取工程的配置参数
        this.opeParam.prjInfo = files.pullJsonInfo(this.opeParam.propertyPath);

        // CN: 获取用户自定义的工程结构
        if (files.isHasValue(this.opeParam.prjInfo, "PRJ_STRUCTURE", "customer")) {
            this.opeParam.prjStructure.prjPath = this.opeParam.prjInfo.PRJ_Path;

            this.opeParam.prjStructure.HardwareSim  = this.opeParam.prjInfo.HardwareSim.replace(/\\/g, "\/").replace("${workspace}", this.opeParam.workspacePath);
            this.opeParam.prjStructure.HardwareSrc  = this.opeParam.prjInfo.HardwareSrc.replace(/\\/g, "\/").replace("${workspace}", this.opeParam.workspacePath);
            this.opeParam.prjStructure.HardwareData = this.opeParam.prjInfo.HardwareData.replace(/\\/g, "\/").replace("${workspace}", this.opeParam.workspacePath);

            this.opeParam.prjStructure.SoftwareSrc  = this.opeParam.prjInfo.SoftwareSrc.replace(/\\/g, "\/").replace("${workspace}", this.opeParam.workspacePath);
            this.opeParam.prjStructure.SoftwareData = this.opeParam.prjInfo.SoftwareData.replace(/\\/g, "\/").replace("${workspace}", this.opeParam.workspacePath);
            return true;
        }

        // CN: 根据片上系统的类型获取标准工程结构
        this.opeParam.prjStructure.prjPath = `${this.opeParam.workspacePath}/prj`;
        let srcPath = `${this.opeParam.workspacePath}/user`;
        if (!files.isHasValue(this.opeParam.prjInfo, "SOC_MODE.soc", "none")) {
            srcPath = `${this.opeParam.workspacePath}/user/Hardware`;
            this.opeParam.prjStructure.SoftwareSrc  = `${this.opeParam.workspacePath}/user/Software/src`;
            this.opeParam.prjStructure.SoftwareData = `${this.opeParam.workspacePath}/user/Software/data`;
        }
        this.opeParam.prjStructure.HardwareSrc  = `${srcPath}/src`;
        this.opeParam.prjStructure.HardwareSim  = `${srcPath}/sim`;
        this.opeParam.prjStructure.HardwareData = `${srcPath}/data`;

        return true;
    }

    /**
     * 处理整个工程下的文件，包括源代码以及工程配置文件
     * @param {*} ignoreCheck 是否跳过文件个数的检测强制执行 true: 不进行检测 false: 进行检测
     * @returns false: 文件个数超出极限退出运行 true: 文件个数未超出极限可以直接运行
     */
    async processPrjFiles(ignoreCheck) {
        let HDLFileList = [];

        // 处理工程配置信息，同时根据配置信息处理完lib的HDL文件
        // real: 复制到本地src/lib，在本地下进行处理 virutal: 非本地下的HDL文件直接在此处理
        await this.processProperty();

        // 处理本地的HDL文件
        this.getPrjFiles(HDLFileList);

        if (!(this.checkFileNum(HDLFileList) || ignoreCheck)) {
            return false;
        }
        await this.indexer.build_index(HDLFileList);
        console.log(this.indexer.HDLparam);

        return true;
    }

    /**
     * 工程配置文件处理。 (刷新工程信息 -> 更新工程结构 -> 处理非本地HDL文件)
     * @returns null 用于退出工程配置信息的处理
     */
    async processProperty() {
        // 刷新工程信息，如果不存在则直接退出
        if (!this.getPropertyInfo()) {
            return null;
        }
        await this.refreshPrjFolder(); // 更新工程结构
        await this.processLibFiles();  // 处理非本地的lib文件
    }

    /**
     * @descriptionCn 根据工程配置信息刷新工程文件结构
     * @returns null 用于退出无工程配置信息时以及用户自定义工程结构时的情况
     */
    async refreshPrjFolder() {
        // 无工程配置文件则直接退出
        if (!this.opeParam.prjInfo) {
            return null;
        }

        // 如果是用户配置文件结构？
        if (files.isHasValue(this.opeParam.prjInfo, "PRJ_STRUCTURE", "customer")) {
            return null;
        }

        // 先直接创建工程文件夹
        dirs.mkdir(`${this.opeParam.workspacePath}/prj`);

        // 再对源文件结构进行创建
        if (!files.isHasAttr(this.opeParam.prjInfo, "SOC_MODE.soc")) {
            return null;
        }
        
        // 初试化文件结构的路径
        let userPath = `${this.opeParam.workspacePath}/user`;
        let softwarePath = `${this.opeParam.workspacePath}/user/Software`;
        let hardwarePath = `${this.opeParam.workspacePath}/user/Hardware`;

        // 如果不是在soc模式下开发
        if (this.opeParam.prjInfo.SOC_MODE.soc == "none") {
            // 如果存在 software path 则将整个文件夹删除
            if (files.isExist(softwarePath)) {
                if (this.setting.get("PRJ.file.structure.notice")) {
                    // 删除时进行提醒，yes : 删除，no : 保留
                    let select = await this.warn("Software will be deleted.", 'Yes', 'No');
                    if (select == "Yes") {
                        dirs.rmdir(softwarePath);
                    }
                } else {
                    dirs.rmdir(softwarePath);
                }
            }

            // 如果存在 software path 则对该文件夹下一级的所有子目录进行遍历
            // 遍历之后将每个子目录全部移动到 user path 文件夹下
            // 最后再将 hardware path 父级文件夹进行删除
            if (files.isExist(hardwarePath)) {
                let elements = fs.readdirSync(hardwarePath);
                for (let i = 0; i < elements.length; i++) {
                    const element = elements[i];
                    dirs.mvdir(`${hardwarePath}/${element}`, userPath);
                }
                dirs.rmdir(hardwarePath);
                return null;
            } 
            
            // 如果 software path 和 hardware path 都不存在
            // 则直接在 user path 文件夹下构建 {src & sim & data}这三个子项 
            dirs.mkdir(`${userPath}/src`);
            dirs.mkdir(`${userPath}/sim`);
            dirs.mkdir(`${userPath}/data`);
            return null;
        }

        // 如果是soc模式下开发
        // 首先构建 software path 文件夹下的 {src & data} 等子项
        dirs.mkdir(`${softwarePath}/data`);
        dirs.mkdir(`${softwarePath}/src`);

        // 在将原 user path 文件夹下的 {src & sim & data} 子项移动到 hardware path 
        dirs.mvdir(`${userPath}/src`, `${hardwarePath}/src`);
        dirs.mvdir(`${userPath}/sim`, `${hardwarePath}/sim`);
        dirs.mvdir(`${userPath}/data`, `${hardwarePath}/data`);
    }

    /**
     * CN: 获取本地的src(和sim、bd)路径下的HDL文件，lib被包含在src下
     * @param {*} HDLFileList 
     */
    getPrjFiles(HDLFileList) {
        // CN: 当含有工程配置信息时 (才有sim和src之分)
        if (this.opeParam.prjInfo) {
            // CN: 首先获取sim路径下的HDL源文件
            this.getHDLFiles(this.opeParam.prjStructure.HardwareSim, HDLFileList);

            // CN: 获取src路径下的HDL源文件 (针对 IP和bd文件下的HDL进行选择性的获取，获取后直接退出) 
            if (files.isHasAttr(this.opeParam.prjInfo, "TOOL_CHAIN")) {
                // CN: 获取xilinx下bd数据
                if (this.opeParam.prjInfo.TOOL_CHAIN == "xilinx") {
                   this.getXilinxFiles(HDLFileList);
                }
            }
        }

        // CN: 获取src下的全部HDL文件
        this.getHDLFiles(this.opeParam.prjStructure.HardwareSrc, HDLFileList);
    }

    /**
     * CN: 针对xilinx的IP和bd文件下的HDL进行选择性的获取
     * @param {*} HDLFileList 
     * @returns null
     */
    getXilinxFiles(HDLFileList) {
        let bd_path = `${fspath.dirname(this.opeParam.prjStructure.HardwareSrc)}/bd`;
        if (!fs.existsSync(bd_path)) {
            return null;
        }
        let bd_list = fs.readdirSync(bd_path);
        for (let i = 0; i < bd_list.length; i++) {
            const element = bd_list[i];
            this.getHDLFiles(`${bd_path}/${element}/hdl`, HDLFileList);
            this.getHDLFiles(`${bd_path}/${element}/synth`, HDLFileList);
            let ip_path = `${bd_path}/${element}/ip`;
            if (fs.existsSync(ip_path)) {
                let ip_list = fs.readdirSync(ip_path);
                for (let i = 0; i < ip_list.length; i++) {
                    const element = ip_list[i];
                    this.getHDLFiles(`${ip_path}/${element}/synth`, HDLFileList);
                }
            }
        }
    }

    /**
     * CN: 获取文件夹下的所有HDL文件，已经进行了文件存在性的检查，并且同时支持文件和文件夹
     * @param {*} path 
     * @param {*} HDLFileList 
     */
    getHDLFiles(path, HDLFileList) {
        let HDLFileExtnames = [
            // verilog
            ".v", ".V", ".vh", ".vl", 
            // systemverilog
            ".sv", ".SV", 
            // vhdl
            ".vhd", ".vhdl", ".vho", ".vht"
        ];
        files.pickAllFile(path, HDLFileExtnames, HDLFileList);
    }

    async processLibFiles() {
        let localLibPath  = `${this.opeParam.prjStructure.HardwareSrc}/lib`;
        this.localLibPath = this.opeParam.rootPath + "/lib";

        let delLibFileList = [];
        let addLibFileList = [];

        this.newLibFileList = this.getLibFiles();

        // 将硬件库中的源代码复制到本地中去 (与原本地lib文件进行校对删除多余的，添加新增的)
        if (files.isHasValue(this.opeParam.prjInfo, "HardwareLIB.State", "real")) {
            // 将本地lib的路径转换成扩展硬件库下的路径，方便与newLibFileList进行对比
            // 仅当real类型下的时候应该以本地为准，才要将转换后的更新为 oldLibFileList 
            this.oldLibFileList = this.turn_local_to_lib(localLibPath);

            // 将 oldLibFileList 与 newLibFileList 进行对比
            delLibFileList = this.get_del_LibFileList();
            addLibFileList = this.get_add_LibFileList();

            this.turn_lib_to_local(localLibPath, delLibFileList, (src, dist) => {
                files.removeFile(dist);
            })
            delLibFileList = [];

            this.turn_lib_to_local(localLibPath, addLibFileList, (src, dist) => {
                files.copyFile(src, dist);
            })
            addLibFileList = [];

            this.oldLibFileList = [];
        }
        else if (files.isHasValue(this.opeParam.prjInfo, "HardwareLIB.State", "virtual")) {
            delLibFileList = this.get_del_LibFileList();
            addLibFileList = this.get_add_LibFileList();

            this.watcherHDL.add(addLibFileList);
            this.watcherHDL.unwatch(delLibFileList);

            this.addFilesInPrj(addLibFileList);
            this.delFilesInPrj(delLibFileList);
            
            if (fs.existsSync(localLibPath)) {
                if (this.setting.get("PRJ.file.structure.notice")) {
                    let select = await this.warn("The local lib folder will be deleted.", 'Yes', 'Cancel');
                    if (select == "Yes") {
                        dirs.rmdir(localLibPath);
                    }
                } else {
                    dirs.rmdir(localLibPath);
                }
            }

            // 从HDLparam中删除用不到的lib文件
            for (let i = 0; i < delLibFileList.length; i++) {
                const elementPath = delLibFileList[i];
                this.indexer.removeCurrentFileParam(elementPath);
            }
        
            this.oldLibFileList = this.newLibFileList;
            
            // 向HDLparam中添加新lib文件
            this.indexer.build_index(addLibFileList);
            if (this.treeView) {
                this.treeView.refresh();
            }
        }
    }

    /**
     * CN: 从配置信息中获取库文件路径
     * get all the lib files from Common, xilinx, intel, Customer
     * @returns all the lib files from property.json
     */
    getLibFiles() {
        let libFileList = [];

        // Get the HDL file of the local library and put it in libFileList
        if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Common")) {
            for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Common.length; i++) {
                const element = this.opeParam.prjInfo.HardwareLIB.Common[i];
                this.getHDLFiles(`${this.localLibPath}/src_lib/Hardware/${element}`, libFileList);
            }
        }

        // Get the HDL file of the local Xilinx library and put it in libFileList
        if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Xilinx_lib")) {
            for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Xilinx_lib.length; i++) {
                const element = this.opeParam.prjInfo.HardwareLIB.Xilinx_lib[i];
                this.getHDLFiles(`${this.localLibPath}/xilinx_lib/src/${element}`, libFileList);
            }
        }

        // Get the HDL file of the local Intel library and put it in libFileList
        if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Intel_lib")) {
            for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Intel_lib.length; i++) {
                const element = this.opeParam.prjInfo.HardwareLIB.Intel_lib[i];
                this.getHDLFiles(`${this.localLibPath}/Intel_lib/src/${element}`, libFileList);
            }
        }

        // Get the HDL file of the user-defined library and place it in libFileList
        if (files.isHasAttr(this.opeParam.prjInfo, "HardwareLIB.Customer")) {
            // Gets the path to the user-defined library
            let customerlocalLibPath = this.setting.get("PRJ.customer.Lib.repo.path");
            if (fs.existsSync(customerlocalLibPath)) {
                for (let i = 0; i < this.opeParam.prjInfo.HardwareLIB.Customer.length; i++) {
                    const element = this.opeParam.prjInfo.HardwareLIB.Customer[i];
                    this.getHDLFiles(`${customerlocalLibPath}/${element}`, libFileList);
                }
            } else {
                this.err(`The PRJ.customer.Lib.repo.path ${PRJ.customer.Lib.repo.path} do not exist.`);
            }
        }

        // Remove duplicate HDL files
        libFileList = this.removeDuplicates(libFileList);
        return libFileList;
    }

    /**
     * CN: 将 old 与 new 进行对比，将不需要的进行删除
     * EN: delete the lib file from old lib file list
     * @returns The lib file to delete
     */
    get_del_LibFileList() {
        let delLibFileList = [];
        for (let i = 0; i < this.oldLibFileList.length; i++) {
            const oldLibFileElement = this.oldLibFileList[i];
            if (!this.newLibFileList.includes(oldLibFileElement)) {
                delLibFileList.push(oldLibFileElement);
            }
        }
        return delLibFileList;
    }

    /**
     * CN: 将 new 与 old 进行对比，将不需要的进行删除
     * EN: add the lib file from new lib file list
     * @returns The lib file to add
     */
    get_add_LibFileList() {
        let addLibFileList = [];
        for (let i = 0; i < this.newLibFileList.length; i++) {
            const newLibFileElement = this.newLibFileList[i];
            if (!this.oldLibFileList.includes(newLibFileElement)) {
                addLibFileList.push(newLibFileElement);
            }
        }
        return addLibFileList;
    }

    /**
     * CN: 将本地lib路径转到硬件库的源代码路径
     * @param {*} localLibPath  工作区存放lib的路径
     * @returns 将工作区的路径转成扩展硬件库的路径
     */
    turn_local_to_lib(localLibPath) {
        let libFiles = [];
        let localLibFiles = [];
        let customerlocalLibPath = this.setting.get("PRJ.customer.Lib.repo.path");

        // 获取原本地lib文件夹下的所有HDL文件
        // TODO: 可以尝试使用Map的key进行快速提取，无需重新解析
        this.getHDLFiles(localLibPath, localLibFiles);

        // 遍历本地lib下的所有源文件，并且进行路径的转换
        for (let i = 0; i < localLibFiles.length; i++) {
            const localLibElement = localLibFiles[i];
            if (localLibElement.indexOf("customer") != -1) {
                libFiles.push(localLibElement.replace(`${localLibPath}/customer`, customerlocalLibPath));
            } else {
                // 已经保留了 src_lib、xilinx_lib 等文件夹的声明
                libFiles.push(localLibElement.replace(localLibPath, this.localLibPath));
            }
        }
        return libFiles;
    }

    /**
     * CN: 将硬件库中的源代码路径转到本地lib路径
     * @param {*} localLibPath 
     * @param {*} libFiles 
     * @param {*} callback 
     */
    turn_lib_to_local(localLibPath, libFiles, callback) {
        let localLibFiles = [];
        let customerlocalLibPath = this.setting.get("PRJ.customer.Lib.repo.path");

        // 遍历硬件库中的源代码
        for (let i = 0; i < libFiles.length; i++) {
            const libFileElement = libFiles[i];
            let dist = "";
            if (libFileElement.indexOf(customerlocalLibPath) != -1) {
                dist = libFileElement.replace(customerlocalLibPath, `${localLibPath}/customer`);
                localLibFiles.push(dist);
            } 
            else if (libFileElement.indexOf(this.localLibPath) != -1) {
                dist = libFileElement.replace(this.localLibPath, localLibPath);
                localLibFiles.push(dist);
            }
            let src  = libFileElement;
            callback(src, dist);
        }

        return localLibFiles;
    }

    /**
     * Remove duplicate element form the array
     * @param {*} array the array need to be removed duplicate element
     * @returns 
     */
    removeDuplicates(array) {
        let h = {};
        let arr = [];
        let len = array.length;
        for (let index = 0; index < len; index++) {
            if(!h[array[index]]){
                arr.push(array[index]);
            }
        }
        return arr;
    }

    checkFileNum(HDLFileList) {
        let limitNum = this.setting.get("PRJ.file.limit.number");
        if (HDLFileList.length > limitNum) {
            this.warn(`The project has exceeded the limit of ${HDLFileList.length} HDL files, \
            so parsing and parse-related functions will be stopped directly.`);
            return false;
        }
        return true;
    }

    checkPrjStruct(struct) {
        let result = true;
        let log = '';

        if (struct.HardwareSrc) {
            if (dirs.isillegal(struct.HardwareSrc)) {
                result = false;
                log += `HardwareSrc is illegal.\n`
            }
        }

        if (struct.HardwareSim) {
            if (dirs.isillegal(struct.HardwareSim)) {
                result = false;
                log += `HardwareSim is illegal.\n`
            }
        }

        if (struct.HardwareData) {
            if (dirs.isillegal(struct.HardwareData)) {
                result = false;
                log += `HardwareData is illegal.\n`
            }
        }

        if (struct.SoftwareSrc) {
            if (dirs.isillegal(struct.SoftwareSrc)) {
                result = false;
                log += `SoftwareSrc is illegal.\n`
            }
        }

        if (struct.SoftwareData) {
            if (dirs.isillegal(struct.SoftwareData)) {
                result = false;
                log += `SoftwareData is illegal.\n`
            }
        }
        
        if (!result) {
            this.err(log);
        }

        return result;
    }

    addFilesInPrj(filePaths) {
        if (!this.terminal) {
            return null;
        }
        if (files.isHasAttr(this.opeParam.prjInfo, "TOOL_CHAIN")) {
            if (this.opeParam.prjInfo.TOOL_CHAIN == "xilinx") {
                this.processFileInPrj(filePaths, "add_file");
            }				
        }
    }

    delFilesInPrj(filePaths) {
        if (!this.terminal) {
            return null;
        }
        if (!files.isHasAttr(this.opeParam.prjInfo, "TOOL_CHAIN")) {
            if (this.opeParam.prjInfo.TOOL_CHAIN == "xilinx") {
                this.processFileInPrj(filePaths, "remove_files");
            }				
        }
    }

    processFileInPrj(filePaths, command) {
        for (let i = 0; i < filePaths.length; i++) {
            const libFileElement = filePaths[i];
            this.terminal.sendText(`${command} ${libFileElement}`);
        }
    }

    monitorHDL() {
        let watcherConfig = {
            persistent: true,
            usePolling: false,
            ignoreInitial: true,
            // awaitWriteFinish: {   // ms
            //     stabilityThreshold: 2000,
            //     pollInterval: 100
            // }
        }
        
        let watcherPath = `${this.opeParam.workspacePath}/**/*{v,V,sv,SV,vh,vl,vhd,vhdl,vho,vht}`;
        this.watcherHDL = chokidar.watch(watcherPath, watcherConfig);

        // 添加监听事件
        this.watcherHDL.on('add', (path) => {
            path = path.replace("//","/").replace(/\\/g,"\/");

            // 解析新增的HDL文件
            this.indexer.processFile(path);
            this.indexer.refreshInstModulePath();
            if (this.treeView) {
                this.treeView.refresh();
            }
            
            // 向工程中添加该HDL文件
            if (!path.includes(`${this.opeParam.prjStructure.HardwareSrc}/bd`)) {
                this.addFilesInPrj([path]);
            }
        });
        this.watcherHDL.on('unlink', async (path) => {
            path = path.replace("//","/").replace(/\\/g,"\/");

            // 从 HDLparam & symbols 中删除该HDL文件的相关信息
            this.indexer.removeCurrentFileParam(path);
            this.indexer.refreshInstModulePath();
            if (this.treeView) {
                this.treeView.refresh();
            }

            // 向工程中删除该HDL文件
            this.delFilesInPrj([path]);
        });
        this.watcherHDL.on('change', (path) => {
            path = path.replace("//","/").replace(/\\/g,"\/");
            this.indexer.removeCurrentFileParam(path);
            this.indexer.processFile(path);
            console.log(this.indexer.HDLparam);
            this.indexer.refreshInstModulePath();
            if (this.treeView) {
                this.treeView.refresh();
            }
        });
    }

    monitorProperty() {
        let watcherConfig = {
            persistent: true,
            usePolling: false,
            ignoreInitial: true,
            // awaitWriteFinish: {   // ms
            //     stabilityThreshold: 2000,
            //     pollInterval: 100
            // }
        }
        let watcherPath = `${this.opeParam.workspacePath}/**/property.json`;
        let watcher = chokidar.watch(watcherPath, watcherConfig);

        // 添加监听事件
        watcher.on('add', async (path) => {
            path = path.replace("//","/").replace(/\\/g,"\/");
            await this.processProperty();
            await this.watcherPrjLog.close();
            this.monitorPrjLog();
        });
        watcher.on('unlink', async (path) => {
            path = path.replace("//","/").replace(/\\/g,"\/");
            await this.processProperty();
        });
        watcher.on('change', async (path) => {
            path = path.replace("//","/").replace(/\\/g,"\/");
            await this.processProperty();
            await this.watcherPrjLog.close();
            this.monitorPrjLog();
        });
    }

    monitorPrjLog() {
        let prjPath = this.opeParam.prjStructure.prjPath;
        if (prjPath == "") {
            return null;
        }
        
        let watcherConfig = {
            persistent: true,
            usePolling: false,
            ignoreInitial: true,
            // awaitWriteFinish: {   // ms
            //     stabilityThreshold: 2000,
            //     pollInterval: 100
            // }
        }
        let watcherPath = `${prjPath}/**/*.log`;
        this.watcherPrjLog = chokidar.watch(watcherPath, watcherConfig);

        // 添加监听事件
        this.watcherPrjLog.on('change', async (path) => {
            if (this.hardware) {
                this.hardware.outputLog(path);
            }
        });
    }

    generatePropertyFile() {
        if (this.opeParam.prjInfo) {
            vscode.window.showWarningMessage("property file already exists !!!");
            return null;
        }
        var _this = this;
        vscode.window.showQuickPick(['.vscode', 'root'], { placeHolder: "Where you want to generate?" }).then(function (select) {
            // "Where you want to generate?"
            if (select == ".vscode") {
                _this.opeParam.propertyPath = `${_this.opeParam.workspacePath}/.vscode/property.json`;
            } else if (select == "root") {
                _this.opeParam.propertyPath = `${_this.opeParam.workspacePath}/property.json`;
            }
            files.pushJsonInfo(_this.opeParam.propertyPath, files.pullJsonInfo(_this.opeParam.prjInitParam));
        });
    }

    overwriteInitProperty() {
        let initPropertyPath = `${this.opeParam.rootPath}/prjInitParam.json`
        const options = {
            preview: false,
            viewColumn: vscode.ViewColumn.Active
        };
        vscode.window.showTextDocument(vscode.Uri.file(initPropertyPath), options);
    }
}
exports.processPrjFiles = processPrjFiles;
