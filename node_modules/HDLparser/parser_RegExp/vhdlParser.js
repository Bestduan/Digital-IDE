"use strict";
const filesys = require("HDLfilesys");

var regExp = {
    blankRegExp : /\s+/g,

    spaceRegExp : /\s*/g,

    l_comment : new RegExp([
        /--.*/g
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg'),

    b_comment : new RegExp([
        /\/\*[\s\S]*?\*\//
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg'),

    modules : new RegExp([
        /entity\s+(?<name>[\\\$\w]+?)\s*is\s*?/,
        /(generic\s*\((?<param>[\w\W]*?)\)\s*;)?\s*?/,
        /(port\s*\((?<port>[\w\W]*?)\)\s*;)?\s*?/,
        /end/,
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mgi'),

    ports : new RegExp([
        /(?<name>[\w,\s]+)/,
        /\s*:\s*/,
        /(?<type>in|out|inout|buffer)\s+/,
        /(?:\w*\s*)/,
        /(?<width>\([0-9]+\s+downto\s+[0-9]+\))?/,
        /\s*?(\)|;)/
    ].map(x => x.source).join(''), 'mgi'),

    params : new RegExp([
        /(?<name>[\\\$\w]+)/,
        /\s*:\s*/,
        /(?<type>integer|natural|postive|time|std_logic_vector)\s*/,
        /(:=\s*(?<init>.+))?/,
        // /\s*?(\)|;)/
    ].map(x => x.source).join(''), 'mgi'),

    singals : new RegExp([
        /signal\s*/,
        /(?<name>[\w,\s]+)/,
        /\s*:\s*/,
        /(?:\w*\s*)/,
        /(?<width>\([0-9]+\s+downto\s+[0-9]+\))?/,
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mgi'),

    constants : new RegExp([
        /(?<type>constant|variable)\s+/,
        /(?<name>[\\\$\w]+)/,
        /\s*:\s*/,
        /(?<mode>integer|natural|postive|time|std_logic_vector)\s*/,
        /(?<width>\([0-9]+\s+downto\s+[0-9]+\))?/,
        // /\s*?(\)|;)/
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg'),

    instances : new RegExp([
        /(?<name>[\\\$\w]+?)/,
        /\s*:\s*/,
        /(?<type>[\\\$\w]+?)\s+/,
        /(?:generic?\s*?map\s*?\((?<params>[\w\W]*?)\))?\s*/,
        /(?:port\s+map\s*\((?<ports>[\w\W]*?)\))\s*;/,
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mgi'),

    methods : new RegExp([
        /function\s+?/,
        /(?<name>[\\\$\w]+)\s*?/,
        /\([\w\W]+?\)\s*?/,
        /return\s*[\\\$\w]+?\s*?is/,
        /\s*?begin/,
        /(?:[\w\W]*?)/, // <body>
        /end/
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mgi'),

    generate_begin : new RegExp([
        /(?<name>[\\\$\w]+?)/,
        /\s*:\s*/,
        /(?<type>if|for)/,
        /[\w\W]*?/,
        /generate/,
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mgi'),

    generate_end : new RegExp([
        /(?<=\s)/,
        /end\s*?generate/,
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mgi'),

    processes : new RegExp([
        /(?:(?<name>[\\\$\w]+?)\s*:\s*)?/,
        /process/,
        /((?<event>\([\w\W]*?\)))?/,
        /(?<body>[\w\W]+?)/,
        /end\s*process/,
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mgi'),
}

var vhdlParser = {
    getFileParam : function (path, option, HDLparam) {
        try {
            return this.get_modules(path, option, HDLparam);
        }
        catch (error) {
            console.log(error);
            return null;
        }
    },

    /**
     * @state unfinshed - untest
     * @descriptionCn 获取模块的详细属性
     * @param {String} path     需要解析的代码文件的绝对路径  
     * @param {Array}  HDLparam 在快解析模式下模块的详细属性存放的数组
     * @param {Object} option   获取时需要操作的选项 
     * @returns 模块的详细属性item (text & name & type & offset & parent & startIndex & lastIndex)
     */
    get_modules : function(path, option, HDLparam) {
        // option是必须的
        if (!option) {
            return [];
        }
        // 冗余包含文件引用，即每个模块均包含文件include
        let items = [];
        let text = filesys.files.readFile(path);
        text = this.del_comments(text);
        while (1) {
            let match = regExp.modules.exec(text);
            if (match == null) {
                break;      
            }
            
            let item = {
                // 次级解析text解析整个模块内容，(port | param) 最后独立解析
                'text' : text, 
                'name' : match.groups.name,
                'type' : "module",
                'offset' : 0,
                'parent' : null,
                "startIndex": match.index,
                "lastIndex" : match.index + match[0].length,
            };

            // 仅定义为true时运行，null，false时均全运行
            if (option.isFast) {
                let structure = {
                    "includes"   : [],
                    "languageId" : "vhdl",
                    'moduleName' : match.groups.name,
                    'modulePath' : path,
                    "instances"  : this.get_instances(item),
                    "startIndex" : match.index,
                    "lastIndex"  : match.index + match[0].length,
                };
                HDLparam.push(structure);
                continue;
            }

            // 非fast模式下时，只需要导出当前文件下的symbol information
            if (option.symbol) {
                option.symbol.setSymbolInfo(item);
            }

            // 可包含语句块的解析 将解析完后的语句块进行删除
            this.get_methods(item, option.symbol);
            this.get_generates(item, option.symbol);

            // 不可包含语句块的解析
            this.get_signals(item, option.symbol);
            this.get_instances(item, option.symbol);
            this.get_processes(item, option.symbol);
            
            // 最后进行(port | param)的解析
            this.get_ports(item, option.symbol);
            this.get_params(item, option.symbol);
        }
        return HDLparam;
    },

    /**
     * @state unfinshed - untest
     * @descriptionCn 获取模块下generate语句块的相关属性
     * @param {Object} content 父级内容 (text & offset) 对其操作后会保留操作结果
     * @param {Object} symbol  标识符处理方法的对象
     * @returns {Array} generate语句块的详细相关属性组 (name & type & parent & startIndex & lastIndex)
     */
    get_generates : function (content, symbol) {
        let items = [];
        let startItems = [];
        let lastItems  = [];
        while (1) {
            let match = regExp.generate_begin.exec(content.text);
            if (match == null) {
                break;      
            }
            if (match.groups.name == null) {
                match.groups.name = "generate-(no name)";
            }
            let item = {
                "text": '',
                "name": match.groups.name,
                "type": "generate",
                "offset": match.index + content.offset,
                "parent": content.name,
                "startIndex": match.index + content.offset,
                "lastIndex" : match.index + match[0].length + content.offset,
            };
            startItems.push(item);
        }
        if (startItems.length == 0) {
            return items;
        }
        while (1) {
            let match = regExp.generate_end.exec(content.text);
            if (match == null) {
                break;      
            }
            lastItems.push(match.index + match[0].length + content.offset);
        }

        // 进行平衡组匹配
        this.get_balance(items, startItems, lastItems);

        // 对匹配好后的generate语句块进行解析
        for (let index = 0; index < items.length; index++) {
            const itemsElement = items[index];

            // 将该项存入symbols
            if (symbol) {
                symbol.setSymbolInfo(itemsElement);
            }

            // 更新项中的text文本内容
            itemsElement.text = content.text.substring(
                itemsElement.startIndex-content.offset, 
                itemsElement.lastIndex-content.offset
            );

            // get blocks
            this.get_methods(itemsElement, symbol);
        
            // 不可包含语句块的解析
            this.get_signals(itemsElement, symbol);
            this.get_instances(itemsElement, symbol);
            this.get_processes(itemsElement, symbol);
            
            // 最后进行(port | param)的解析
            this.get_ports(itemsElement, symbol);
            this.get_params(itemsElement, symbol);
            
            // TODO：是否对该语句块进行删除？
            let oldContent = itemsElement.text;
            let newContent = ' '.repeat(itemsElement.text.length);
            content.text = content.text.replace(oldContent,newContent);
        }

        return items;
    },

    /**
     * @state finish - untested
     * @descriptionCn Verilog源代码的方法检测 (function & task) 
     * @param {Object} content 输入内容对象   (text & name & offset)
     * @param {Object} symbol  需要操作的选项 (symbol对象)
     * @return {Array} items   方法的详细相关属性组
     */
    get_methods : function (content, symbol) {
        let items = [];
        while (1) {
            let match = regExp.methods.exec(content.text);
            if (match == null) {
                break;      
            }
            let item = {
                "text": match[0],
                "name": match.groups.name,
                "type": match.groups.type,
                "parent" : content.name,
                "offset" : match.index + content.offset,
                "startIndex": match.index + content.offset,
                "lastIndex" : match.index + match[0].length + content.offset,
            };
            items.push(item);

            // 将该项存入symbols
            if (symbol) {
                symbol.setSymbolInfo(item);
            }

            this.get_ports(item, symbol);
            this.get_signals(item, symbol);
            let oldContent = match[0];
            let newContent = ' '.repeat(match[0].length);
            content.text = content.text.replace(oldContent, newContent);
        }
        return items;
    },

    /**
     * @state finish - untested
     * @descriptionCn Verilog源代码中例化模块的检测
     * @param {Object} content 输入内容对象   (text & name & offset)
     * @param {Object} symbol  需要操作的选项 (symbol对象)
     * @return {Array} items   例化模块的详细相关属性组
     */
    get_instances : function (content, symbol) {
        let items = [];
        while (1) {
            let match = regExp.instances.exec(content.text);
            if (match == null) {
                break;      
            }
    
            let item = {
                "name": match.groups.name,
                "type": "instance",
                "parent" : content.name,
                "instparams": {
                    "startIndex": -1,
                    "lastIndex" : -1,
                },
                "instports" : {
                    "startIndex": -1,
                    "lastIndex" : -1,
                },
                "instName": match.groups.name,   // name
                "instModule": match.groups.type, // type
                "instModPath": "",
                "startIndex": match.index + content.offset,
                "lastIndex" : match.index + match[0].length + content.offset,
            };

            if (match.groups.params != null) {
                item.instparams.startIndex = match.index + content.offset + match[0].indexOf(match.groups.params);
                item.instparams.lastIndex = item.instparams.startIndex + match.groups.params.length;
            }
            if (match.groups.ports != null) {
                item.instports.startIndex = match.index + content.offset + match[0].indexOf(match.groups.ports);
                item.instports.lastIndex = item.instports.startIndex + match.groups.ports.length;
            }

            if (symbol) {
                symbol.setSymbolInfo(item);
            }
            items.push(item);
        }
        return items;
    },

    /**
     * @state finish - untested
     * @descriptionCn Verilog源代码中端口的检测
     * @param {Object} content 输入内容对象   (text & name & offset)
     * @param {Object} symbol  需要操作的选项 (symbol对象)
     * @return {Array} items   例化模块的详细相关属性组
     */
    get_ports : function (content, symbol) {
        let items = [];
        while (1) {
            let match = regExp.ports.exec(content.text);
            if (match == null) {
                break;      
            }
            let item = {
                'name' : "",
                'type' : (match.groups.type == "buffer") ? "buffer" : (match.groups.type + "put"),
                'parent' : content.name,
                "portName"  : "",
                "portWidth" : (match.groups.width == undefined) ? "" : match.groups.width,
                "startIndex": match.index + content.offset,
                "lastIndex" : match.index + match[0].length + content.offset,
            };

            var nameList = match.groups.name.split(",");

            for (let i = 0; i < nameList.length; i++) {
                if (nameList[i] != '') {                                
                    item.name = nameList[i].replace(regExp.spaceRegExp,'');
                    item.portName = item.name;
                    items.push(item);

                    if (symbol) {
                        symbol.setSymbolInfo(item);
                    }
                }
            }
        }

        return items;
    },

    /**
     * @state finish - untested
     * @descriptionCn Verilog源代码中变量的检测
     * @param {Object} content 输入内容对象   (text & name & offset)
     * @param {Object} symbol  需要操作的选项 (symbol对象)
     * @return {Array} items   例化模块的详细相关属性组
     */
    get_params : function (content, symbol) {
        let items = [];
        while (1) {
            let match = regExp.params.exec(content.text);
            if (match == null) {
                break;      
            }
            let item = {
                'name' : "",
                'type' : "parameter",
                'parent' : content.name,
                "paramName"  : "",
                "paramWidth" : (match.groups.width == undefined) ? "" : match.groups.width,
                "paramInit"  : (match.groups.init == undefined)  ? "" : match.groups.init,
                "startIndex" : match.index + content.offset,
                "lastIndex"  : match.index + match[0].length + content.offset,
            };

            var nameList = match.groups.name.split(",");

            for (let i = 0; i < nameList.length; i++) {
                if (nameList[i] != '') {                                
                    item.name = nameList[i].replace(regExp.spaceRegExp,'');
                    item.paramName = item.name;
                    items.push(item);
                    
                    if (symbol) {
                        symbol.setSymbolInfo(item);
                    }
                }
            }
        }
        return items;
    },

    /**
     * @state finish - untested
     * @descriptionCn Verilog源代码中信号线的检测
     * @param {Object} content 输入内容对象   (text & name & offset)
     * @param {Object} symbol  需要操作的选项 (symbol对象)
     * @return {Array} items   例化模块的详细相关属性组
     */
    get_signals : function (content, symbol) {
        let items = [];
        while (1) {
            let match = regExp.singals.exec(content.text);
            if (match == null) {
                break;      
            }

            let item = {
                'name' : "",
                'type' : "logic",
                'parent': content.name,
                'range': (match.groups.width == undefined) ? "" : match.groups.width,
                "startIndex": match.index + content.offset,
                "lastIndex" : match.index + match[0].length + content.offset,
            };

            var nameList = match.groups.name.split(",");

            for (let i = 0; i < nameList.length; i++) {
                if (nameList[i] != '') {                                
                    item.name = nameList[i].replace(regExp.spaceRegExp,'');
                    items.push(item);

                    if (symbol) {
                        symbol.setSymbolInfo(item);
                    }
                }
            }
        }
        return items;
    },

    /**
     * @state finish - untested
     * @descriptionCn Verilog源代码中always语句处理块的检测
     * @param {Object} content 输入内容对象   (text & name & offset)
     * @param {Object} symbol  需要操作的选项 (symbol对象)
     * @return {Array} items   例化模块的详细相关属性组
     */
    get_processes : function (content, symbol) {
        let items = [];
        while (1) {
            console.log(regExp.processes.lastIndex);
            let match = regExp.processes.exec(content.text);
            if (match == null) {
                break;      
            }
            let processName = match.groups.name;
            if (processName == null) {
                if (match.groups.event == null) {
                    processName = "processe" + "-Unconditional";
                } else {
                    processName = "processe" + "-" + match.groups.event.replace(regExp.blankRegExp, ' ');
                }
            } else {
                if (match.groups.event == null) {
                    processName = processName + ":" + "Unconditional";
                } else {
                    processName = processName + ":" + match.groups.event.replace(regExp.blankRegExp, ' ');
                }
            }
            let item = {
                "text": match[0],
                "name": processName,
                "type": "processe",
                "parent" : content.name,
                "offset" : match.index + content.offset,
                "startIndex": match.index + content.offset,
                "lastIndex" : match.index + match[0].length + content.offset,
            };
            items.push(item);

            if (symbol) {
                symbol.setSymbolInfo(item);
            }

            this.get_signals(item, symbol);
            let oldContent = match[0];
            let newContent = ' '.repeat(match[0].length);
            content.text = content.text.replace(oldContent, newContent);
        }
        return items;
    },

    /**
     * @state finish - tested
     * @descriptionCn 进行平衡组的解析输出平衡组的起始与终止的index
     * @param {Array} beginItems 
     * @param {Array} endItems 
     * @returns 
     */
    get_balance(items, startItems, lastItems) {
        if (lastItems.length == 0) {
            return items;
        }
        let times = 0;
        let limitLen = lastItems.length + startItems.length;
        while (lastItems.length && startItems.length) {
            for (let i = 0; i < startItems.length; i++) {
                const startIndexElement = startItems[i].lastIndex;
                // ((())) 成对嵌套情况 (包括优先解决单个成对情况)
                if (i == startItems.length-1) {
                    if (i>=1) {
                        startItems[i].parent = startItems[i-1].name;
                    }
                    // 解决左侧多余匹配情况
                    if (lastItems.length) {
                        startItems[i].lastIndex = lastItems[0];
                    } else {
                        return items;
                    }
                    items.push(startItems[i]);
                    startItems.splice(i,1);
                    lastItems.splice(0,1);
                    break;
                }
                // ()() 成对相连的情况
                if (startIndexElement > lastItems[0]) {
                    if (i>=1) {
                        if (i>=2) {
                            startItems[i-1].parent = startItems[i-2].name;
                        }
                        startItems[i-1].lastIndex = lastItems[0];
                        items.push(startItems[i-1]);
                        startItems.splice(i-1,1);
                    }
                    // 如果i为0则第一个右侧无法匹配 解决右侧多余匹配情况
                    lastItems.splice(0,1);
                    break;
                }
            }
            // 强制退出的保险机制
            times++;
            if (times > limitLen) {
                return items;
            }
        }
        return items;
    },

    /**
     * @state finish - tested
     * @descriptionCn 将文本中的注释全部去掉
     * @descriptionEn delete all comment form verilog code
     * @param {String} text Verilog code input
     * @returns Verilog code output after deleting all comment content
     */
    del_comments : function (text) {
        let match = text.match(regExp.b_comment);
        if (match != null) {
            for (let i = 0; i < match.length; i++) {
                const element = match[i];
                const newElement = ' '.repeat(element.length);
                text = text.replace(element,newElement);
            }
        }
        match = text.match(regExp.l_comment);
        if (match != null) {
            for (let i = 0; i < match.length; i++) {
                const element = match[i];
                const newElement = ' '.repeat(element.length);
                text = text.replace(element,newElement);
            }
        }
        return text;
    },

    /**
     * @state finish - tested
     * @descriptionCn 获取Verilog代码中的注释范围
     * @param {String} text   Verilog代码文本
     * @param {Number} offset text文本在整个代码段中的偏移
     * @returns 由注释范围对象所组成的数组
     */
    get_comment_index : function(text, offset) {
        let commentIndex = [];
        let commentRegExps = [regExp.b_comment, regExp.l_comment];
        for (let i = 0; i < commentRegExps.length; i++) {
            while (1) {
                let match = commentRegExps[i].exec(text);
                if (match == null) {
                    break;
                }
                let index = {
                    "startIndex" : 0,
                    "lastIndex"  : 0
                }
                index.startIndex = match.index + offset ? offset : 0;
                index.lastIndex = match.index + match[0].length + offset ? offset : 0;
                commentIndex.push(index);
            }
        }
        return commentIndex;
    }
}
module.exports = vhdlParser;


