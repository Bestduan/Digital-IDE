"use strict";
const filesys = require("HDLfilesys");

var regExp = {
    l_comment : /\/\/.*/mg,

    b_comment : /\/\*[\s\S]*?\*\//mg,

    wavePath : /\$dumpfile\s*\(\s*\"(.+){1}\"\s*\);/ig,

    include : new RegExp([
        /`include\s*?/,
        /[\"\']\s*?(?<path>.+)\s*?[\"\']/
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg'),

    define : new RegExp([
        /(?<type>`define|`undef)\s+?/,
        /(?<name>[\\\$\w]+)/,
        /(?<ports>\(.*?\)\s*)?/,
        /(?<body>.*)/
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg'),

    if_else_def : new RegExp([
        /(?<type>`ifdef|`ifndef|`elsif|`else|`endif)\s+?/,
        /(?<name>[\\\$\w]+)?/
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg'),

    modules : new RegExp([
        /(?<!\w)/,
        /module\s+/,
        /(?:automatic\s+)?/,
        /(?<name>[\\\$\w]+?)/,
        /(?<params>\s*#\s*\([\w\W]*?\))?/, // <params>
        /(?<ports>\s*\([\W\w]*?\))?/,      // <ports>
        /\s*;/,
        /(?<body>[\W\w]*?)/,        // <body>
        /endmodule/,
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg'),

    ports : new RegExp([
        /(?<!\w)/,
        /(?<type>input|output|inout)\s/,
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg'),

    singals : new RegExp([
        /(?<!(input|output|inout|,)\s*)/,
        /(?<type>(?<!\w)(reg|wire|logic))\s/,
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg'),

    constants : new RegExp([
        /(?<!\w)/,
        /(?<type>parameter|localparam|genvar|integer|int|char|float)\s/,
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg'),

    instances : new RegExp([
        /(?<type>[\\\$\w]+)\s*/,
        /(#\s*\(\s*(?<params>\.[\w\W]*?)?\))?\s*/,
        /(?<name>[\\\$\w]+)?\s*/,
        /(\(\s*(?<ports>\.[\w\W]*?)?\))/,
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg'),

    methods : new RegExp([
        /(?<!\w)/,
        /(?<type>(function|task))\s+/,
        /((?<return>\[.+?\])\s+)?/,
        /(?<name>[\\\$\w]+)\s*/,
        /(?<ports>\([\W\w]*?\))?/,
        /\s*;/,
        /(?<body>[\w\W]*?)/,
        /(?:end(?:function|task))/
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg'),

    generates : new RegExp([
        /(?<!\w)/,
        /(?<type>(generate|endgenerate))/,
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg'),

    processes = new RegExp([
        /(?<!\w)/,
        /(?<type>always|always_ff|always_comb)/,
        /(\s*@\s*(?<event>\([\w\W]*?\)))?\s*/,
        /(begin\s*:\s*(?<name>\w+))?/,
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg'),

    labels : new RegExp([
        /(?<!\w)/,
        /(?<type>(for|if))\s*/,
        /\([\w\W]*?\)\s*/,
        /begin\s*:\s*(?<name>[\\\$\w]+)/,
    ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg'),
}

var vlogParser = {
    getFileParam : function (path, HDLparam, option) {
        try {
            this.get_modules(path, HDLparam, option);
        }
        catch (error) {
            console.log(error);
            return null;
        }
    },

    get_modules : function(path, HDLparam, option) {
        // option是必须的
        if (!option) {
            return [];
        }
        // 冗余包含文件引用，即每个模块均包含文件include
        let items = [];
        let text = this.preProcess(path, option);
        while (1) {
            let match = regExp.modules.exec(text);
            if (match == null) {
                break;      
            }
            let offset = match[0].indexOf(match.groups.body) + match.index;
            let item = {
                'text' : match.groups.body,
                'name' : match.groups.name,
                'type' : "module",
                'offset' : offset,
                'parent' : null,
                "startIndex": match.index,
                "lastIndex" : match.index + match[0].length,
            };
            if (option.isFast) {
                // 仅定义为true时运行，null，false时均全运行
                let structure = {
                    "includes"   : this.get_include(text, path),
                    'moduleName' : match.groups.name,
                    'modulePath' : path,
                    "instances"  : this.get_instances(match.groups.body, offset),
                    "startIndex" : match.index,
                    "lastIndex"  : match.index + match[0].length,
                };
                HDLparam.push(structure);
                break;
            }

            // 非fast模式下时，只需要导出当前文件下的symbol information
            option.symbol.setSymbolInfo(item);

            this.get_methods(item, option);

        }
        return items;
    },

    get_generates : function (content, option) {
        let beginItems = [];
        let endItems = [];
        while (1) {
            let match = regExp.generates.exec(content.text);
            if (match == null) {
                break;      
            }
            
            let item = {
                "name": parent,
                "type": "generate",
                "parent": parent,
                "startIndex": match.index + content.offset,
                "lastIndex" : match.index + match[0].length + content.offset,
            };
            switch (match.groups.type) {
                case "generate":
                    beginItems.push(item);
                break;
                case "endgenerate":
                    endItems.push(item);
                break;
                default: break;
            }
            
        }

        let result = this.get_balance(beginItems, endItems);
        for (let index = 0; index < result.items.length; index++) {
            const itemsElement = result.items[index];
            let generate_text = content.text.substring(itemsElement.startIndex-content.offset, itemsElement.lastIndex-content.offset);
            let oldContent = generate_text;
            let newContent = ' '.repeat(generate_text.length);
            content.text = content.text.replace(oldContent,newContent);
        }
        return items;
    },

    get_methods : function (content, option) {
        while (1) {
            let match = regExp.methods.exec(content.text);
            if (match == null) {
                break;      
            }
            let item = {
                "text": match[0],
                "name": match.groups.name,
                "type": match.groups.type,
                "offset" : match.index + content.offset,
                "parent" : content.name,
                "startIndex": match.index + content.offset,
                "lastIndex" : match.index + match[0].length + content.offset,
            };
            option.symbol.setSymbolInfo(item);

            this.get_ports(item, option);
            this.get_signals(item, option);
            let oldContent = match[0];
            let newContent = ' '.repeat(match[0].length);
            content.text = content.text.replace(oldContent,newContent);
        }
    },

    get_instances : function (content, option) {
        let items = [];
        while (1) {
            let match = regExp.instances.exec(content.text);
            if (match == null) {
                break;      
            }
    
            let item = {
                "name": match.groups.name,
                "type": "instance",
                "parent" : content.name,
                "instparams": {
                    "startIndex": -1,
                    "lastIndex" : -1,
                },
                "instports" : {
                    "startIndex": -1,
                    "lastIndex" : -1,
                },
                "instName": match.groups.name,   // name
                "instModule": match.groups.type, // type
                "instModPath": "",
                "startIndex": match.index + content.offset,
                "lastIndex" : match.index + match[0].length + content.offset,
            };

            if (match.groups.params != null) {
                item.instparams.startIndex = match.index + content.offset + match[0].indexOf(match.groups.params);
                item.instparams.lastIndex = item.instparams.startIndex + match.groups.params.length;
            }
            if (match.groups.ports != null) {
                item.instports.startIndex = match.index + content.offset + match[0].indexOf(match.groups.ports);
                item.instports.lastIndex = item.instports.startIndex + match.groups.ports.length;
            }
            if (!option.isFast) {
                option.symbol.setSymbolInfo(item);
            }
            items.push(item);
        }
        return items;
    },

    get_ports : function (content, option) {
        let items = [];
        while (1) {
            let match = regExp.ports.exec(content.text);
            if (match == null) {
                break;      
            }
            let key_words = ["input", "output", "inout"];
            let offset = match.index + match[0].length;
            let portInfo = this.get_data_info(content.text, offset, key_words);
            for (let i = 0; i < portInfo.datas.length; i++) {
                let item = {
                    'name' : "",
                    'type' : match.groups.type,
                    'parent' : content.name,
                    "portName" : "",
                    "portWidth": "",
                    "startIndex": match.index + content.offset,
                    "lastIndex" : portInfo.last + content.offset,
                };
                const port = portInfo.datas[i];
                item.portWidth = port.width;
                item.name = port.name;
                item.portName = item.name;
                items.push(item);
                option.symbol.setSymbolInfo(item);
            }
        }
        return items;
    },

    get_constants : function (content, option) {
        let items = [];
        while (1) {
            let match = regExp.singals.exec(content.text);
            if (match == null) {
                break;      
            }
            let key_words = ["parameter","localparam","int","char","float","integer"];
            let offset = match.index + match[0].length;
            let signalInfo = this.get_data_info(content.text, offset, key_words);
            for (let i = 0; i < signalInfo.datas.length; i++) {
                let item = {
                    'name' : "",
                    'type' : match.groups.type,
                    'parent' : content.name,
                    'range': "",
                    "startIndex": match.index + content.offset,
                    "lastIndex" : signalInfo.last + content.offset,
                };
                const signal = signalInfo.datas[i];
                item.name  = signal.name;
                item.range = signal.width;
                if (item.type == "parameter") {
                    items.push(item);
                }
                option.symbol.setSymbolInfo(item);
            }
        }
        return items;
    },

    get_signals : function (content, option) {
        while (1) {
            let match = regExp.singals.exec(content.text);
            if (match == null) {
                break;      
            }
            let key_words = ["reg","wire","logic"];
            let offset = match.index + match[0].length;
            let signalInfo = this.get_data_info(content.text, offset, key_words);
            for (let i = 0; i < signalInfo.datas.length; i++) {
                let item = {
                    'name' : "",
                    'type' : match.groups.type,
                    'parent' : content.name,
                    'range': "",
                    "startIndex": match.index + content.offset,
                    "lastIndex" : signalInfo.last + content.offset,
                };
                const signal = signalInfo.datas[i];
                item.name  = signal.name;
                item.range = signal.width;
                option.symbol.setSymbolInfo(item);
            }
        }
    },

    get_processes : function (content, option) {
        let blankRegExp = /\s/g;
        while (1) {
            let match = regExp.processes.exec(content.text);
            if (match == null) {
                break;      
            }

            // 分析出always处理块的名称
            let processName = match.groups.name;
            if (processName == null) {
                if (match.groups.event == null) {
                    processName = match.groups.type + "-Unconditional";
                } else {
                    processName = match.groups.type + "-" + match.groups.event.replace(blankRegExp, ' ');
                }
            } else {
                if (match.groups.event == null) {
                    processName = processName + ":" + "Unconditional";
                } else {
                    processName = processName + ":" + match.groups.event.replace(blankRegExp, ' ');
                }
            }

            let item = {
                "name": processName,
                "type": "always",
                "parent" : content.name,
                "startIndex": match.index + content.offset,
                "lastIndex" : match.index + match[0].length + content.offset,
            };
            option.symbol.setSymbolInfo(item);
        }
    },
    
    /**
     * @state finish - tested
     * @descriptionCn Verilog源代码的预处理
     * @param {*} path the path of source code
     * @returns code after preprocess
     */
    preProcess : function (path, option) {
        let defines = new Map();
        let text = this.get_define(path, defines, true);

        let beginItems = [];
        let midItems = [];
        let endItems = [];

        let isPreProcess = false;
        if (option) {
            if (option.isPreProcess != null) {
                isPreProcess = option.isPreProcess;
            }
        }

        while (1) {
            let match = regExp.if_else_def.exec(text);
            if (match == null) {
                break;      
            }
            let item = {
                "level": 0,
                "name": match.groups.name,
                "type": match.groups.type,
                "startIndex": match.index,
                "lastIndex" : match.index + match[0].length,
            };
            text = text.replace(match[0], ' '.repeat(match[0].length));
            if (!isPreProcess) {
                // 如果是跳过预处理则直接跳出循环
                break;
            }
            switch (match.groups.type) {
                case "`ifdef":
                case "`ifndef":
                    if (match.groups.name == null) {
                        break;      
                    }
                    beginItems.push(item);
                break;
                case "`elsif":
                case "`else":
                    midItems.push(item);
                break;
                case "`endif":
                    endItems.push(item);
                break;
                default: break;
            }
        }

        if (!isPreProcess) {
            // 如果是跳过预处理则直接输出源代码
            return text;
        }

        let result = this.get_balance(beginItems, endItems);
        for (let m = result.maxlevel; m >= 0; m--) {
            for (let i = 0; i < result.items.length; i++) {
                const item = result.items[i];
                // 从最里的一层开始依次替换
                if (item.level == m) {
                    let beginIndex = -1;
                    let endIndex = -1;

                    // 如果起始的ifdef或者ifndef成立的时候
                    if (item.type == "`ifdef" && defines.has(item.name)) {
                        beginIndex = item.startIndex;
                    }
                    if (item.type == "`ifndef" && !defines.has(item.name)) {
                        beginIndex = item.startIndex;
                    }

                    // 获取结束的index
                    // 从中间判断条件进行判断
                    for (let n = 0; n < midItems.length; n++) {
                        const middle = midItems[n];
                        if (middle.startIndex > item.startIndex && middle.lastIndex < item.lastIndex) {
                            if (beginIndex == -1) { // 说明起始状态不成立
                                if (middle.type == "`elseif" && defines.has(middle.name)) {
                                    beginIndex = middle.startIndex;
                                }
                                if (middle.type == "`else") {
                                    beginIndex = middle.startIndex;
                                    midItems.splice(n,1);
                                    break;
                                }
                            } else { // 说明起始状态成立
                                endIndex = middle.startIndex;
                                midItems.splice(n,1);
                                break;
                            }

                            // 将其删除以免对更大的定义区间造成干扰
                            midItems.splice(n,1);
                            n--;
                        }
                    }
                    
                    // 从end处进行最后收尾
                    // 如果依旧还没找到需要编译的起始位置则认为整段无定义进行删除
                    let macro_content = text.substring(item.startIndex, item.lastIndex);
                    if (beginIndex == -1) {
                        text = text.replace(macro_content, ' '.repeat(macro_content.length));
                    } else {
                        // 如果只是没找到需要编译的终止位置则认为无中间判断，终止在`end处
                        if (endIndex == -1) {
                            endIndex = item.lastIndex;
                        }
                        let compiler_content = text.substring(beginIndex, endIndex);
                        let front_space = ' '.repeat(beginIndex - item.startIndex);
                        let back_space = ' '.repeat(item.lastIndex - endIndex);
                        compiler_content = front_space + compiler_content + back_space;
                        text = text.replace(macro_content, compiler_content);
                    }
                }
            }
        }

        defines.forEach((value, key) => {
            let regExp = new RegExp(`(?<!\\w)\`${key}(?!\\w)`, 'mg');
            text = text.replace(regExp, value);
        });

        return text;
    },

    /**
     * @state finish - tested
     * @descriptionCn 获取Verilog代码中的include语句并将其转化成绝对路径
     * @param {String} text verilog content after deleting all comment content
     * @param {String} curPath current verilog path
     * @returns {Array} An array of absolute path included in this verilog code
     */
    get_include : function (text, curPath) {
        let items = [];
        while (1) {
            let match = regExp.include.exec(text);
            if (match == null) {
                break;      
            }
            let path = filesys.paths.rel2abs(curPath, match.groups.path);
            items.push(path);
        }
        return items;
    },

    /**
     * @state finish - tested
     * @descriptionCn 获取宏定义内容
     * @param {String} path 源文件路径
     * @param {Map} defines 宏定义的键与值 key : macro_name value : macro_content
     * @param {Boolean} isRecursion 是否递归获取所有的宏定义
     * @returns null
     */
    get_define : function (path, defines, isRecursion) {
        // 获取文件内容
        let text = filesys.files.readFile(path);
        text = this.del_comments(text);

        // 获取本文件中的所有define宏定义
        while (1) {
            let match = regExp.define.exec(text);
            if (match == null || match.groups.name == null) {
                break;      
            }
            if (match.groups.type == "`define") {
                if (!match.groups.body) {
                    break;
                }
                if (match.groups.ports) {
                    match.groups.name += match.groups.ports;
                }
                // note : define是唯一对应的，后面定义的会将前面的冲掉
                defines.set(match.groups.name, match.groups.body);
            }
            else if (match.groups.type == "`undef") {
                defines.delete(match.groups.name);
            }
        }

        if (!isRecursion) {
            return null;
        }

        // 主要是针对 `include 里的define宏定义的情况
        let newText = text;
        defines.forEach((value, key) => {
            let regExp = new RegExp(`(?<!\\w)\`${key}(?!\\w)`, 'mg');
            newText = newText.replace(regExp, value);
        });

        let includes = this.get_include(newText, path);
        for (let i = 0; i < includes.length; i++) {
            const include = includes[i];
            this.get_define(include, defines, true);
        }
        return text;
    },

    getWaveImagePath : function (text) {
        let waveImagePath = text.match(regExp.wavePath);
        waveImagePath = regExp.wavePath.$1;
        if (waveImagePath == undefined) {
            waveImagePath = "";
        }
        return waveImagePath;
    },

    /**
     * @state finish - tested
     * @descriptionCn 进行平衡组的解析输出平衡组的起始与终止的index
     * @param {Array} beginItems 
     * @param {Array} endItems 
     * @returns 
     */
    get_balance : function (beginItems, endItems) {
        let items = [];
        if (beginItems.length == 0) {
            return items;
        }
        if (endItems.length == 0) {
            return items;
        }
        let maxlevel = 0;
        let times = 0;
        let limitLen = endItems.length + beginItems.length;
        while (endItems.length && beginItems.length) {
            for (let i = 0; i < beginItems.length; i++) {
                const startIndexElement = beginItems[i].lastIndex;
                const lastIndexElement = endItems[0].startIndex;
                // ()() 成对相连的情况 (优先解决从而避免最后一个被包含的问题)
                if (startIndexElement > lastIndexElement) {
                    if (i>=1) {
                        if (i>=2) {
                            if (beginItems[i-1].parent) {
                                beginItems[i-1].parent = beginItems[i-2].name;
                            }
                            beginItems[i-1].level = beginItems[i-2].level + 1;
                            if (beginItems[i-1].level > maxlevel) {
                                maxlevel = beginItems[i-1].level;
                            }
                        }
                        beginItems[i-1].lastIndex = endItems[0].lastIndex;
                        items.push(beginItems[i-1]);
                        beginItems.splice(i-1,1);
                    }
                    // 如果i为0则第一个右侧无法匹配 解决右侧多余匹配情况
                    endItems.splice(0,1);
                    break;
                }
                // ((())) 成对嵌套情况 (包括优先解决单个成对情况)
                if (i == beginItems.length-1) {
                    if (i>=1) {
                        if (beginItems[i].parent) {
                            beginItems[i].parent = beginItems[i-1].name;
                        }
                        beginItems[i].level = beginItems[i-1].level + 1;
                        if (beginItems[i].level > maxlevel) {
                            maxlevel = beginItems[i].level;
                        }
                    }
                    // 解决左侧多余匹配情况
                    if (endItems.length) {
                        beginItems[i].lastIndex = endItems[0].lastIndex;
                    } else {
                        return items;
                    }
                    items.push(beginItems[i]);
                    beginItems.splice(i,1);
                    endItems.splice(0,1);
                    break;
                }
            }
            // 强制退出的保险机制
            times++;
            if (times > limitLen) {
                return items;
            }
        }
        return {
            maxlevel : maxlevel,
            items : items
        };
    },

    get_data_info : function (text, offset, key_words) {
        let datas = [];
        let info = {
            "datas" : [],
            "last"  : 0,
        }
    
        let rightBracket = 0;
        let leftBracket  = 0;
    
        let index = offset;
        let lastIndex = 0;
        let spaceFlag = false;
        let nameLock  = false;
        let currentType  = "name";
    
        let currentName  = "";
        let currentInit  = "";
        let currentWidth = "";
    
        while ((text[index] != ';') && (index <= text.length)) {
            switch (text[index]) {
                case '\0' :
                case '\r' :
                case '\t' :
                case '\v' :
                case '\n' :
                case '\f' :
                case ' '  : 
                    spaceFlag = true;
                    if (key_words.includes(currentName)) {
                        info.datas = datas;
                        info.last  = lastIndex;
                        return info;
                    } 
                break;
                case '[' : 
                    currentType = "width";
                    if (!nameLock) {
                        currentWidth = currentWidth + text[index];
                    }
                break;
                case ']' : 
                    if (!nameLock) {
                        currentType = "postwidth"; 
                        currentWidth = currentWidth + text[index];
                    }
                break;
                case '=' : 
                    currentType = "init"; 
                break;
                case ',' : 
                    let data  = {
                        "name"  : "",
                        "init"  : "",
                        "width" : "",
                    }
                    nameLock   = false;
                    lastIndex  = index;
                    data.name  = currentName;
                    data.init  = currentInit;
                    data.width = currentWidth;
                    currentName  = "";
                    currentInit  = "";
                    currentWidth = "";
                    currentType  = "name"
                    datas.push(data);
                break;
                default: 
                    if (text[index] == "(") {
                        leftBracket++;
                    }
                    else if (text[index] == ")") {
                        rightBracket++;
                        if (rightBracket > leftBracket) {
                            let data  = {
                                "name"  : "",
                                "init"  : "",
                                "width" : "",
                            }
                            lastIndex  = index;
                            data.name  = currentName;
                            data.init  = currentInit;
                            data.width = currentWidth;
                            datas.push(data);
                            info.datas = datas;
                            info.last  = lastIndex;
                            return info;
                        }
                    }
                    if (currentType == "init") {
                        spaceFlag = false;
                        currentInit = currentInit + text[index];
                    }
                    else if (currentType == "width") {
                        spaceFlag = true;
                        if (!nameLock) {
                            currentWidth = currentWidth + text[index];
                        }
                    }
                    else if (currentType == "postwidth") {
                        nameLock    = true;
                        spaceFlag   = false;
                        currentType = "name";
                        currentName = text[index];
                    }
                    else if (currentType == "name") {
                        if (spaceFlag) {
                            currentName = "";
                        }
                        spaceFlag = false;
                        currentName = currentName + text[index];
                    }
                break;
            }
            index = index + 1;
        }
        let data  = {
            "name"  : "",
            "init"  : "",
            "width" : "",
        }
        lastIndex  = index;
        data.name  = currentName;
        data.init  = currentInit;
        data.width = currentWidth;
        datas.push(data);
        info.datas = datas;
        info.last  = lastIndex;
        return info;
    },

    /**
     * @state finish - tested
     * @descriptionCn 将Verilog代码中的注释全部去掉
     * @descriptionEn delete all comment form verilog code
     * @param {String} text Verilog code input
     * @returns Verilog code output after deleting all comment content
     */
    del_comments : function (text) {
        let match = text.match(regExp.b_comment);
        if (match != null) {
            for (let i = 0; i < match.length; i++) {
                const element = match[i];
                const newElement = ' '.repeat(element.length);
                text = text.replace(element,newElement);
            }
        }
        match = text.match(regExp.l_comment);
        if (match != null) {
            for (let i = 0; i < match.length; i++) {
                const element = match[i];
                const newElement = ' '.repeat(element.length);
                text = text.replace(element,newElement);
            }
        }
        return text;
    },

    get_comment_range : function(text, offset) {
        let commentRange = [];
        let regexes =  comment;
        for (let i = 0; i < regexes.length; i++) {
            while (1) {
                let match = regexes[i].exec(text);
                if (match == null) {
                    break;
                }
                let Range = {
                    "start"   : 0,
                    "end"     : 0
                }
                Range.start = match.index + offset;
                Range.end = match.index + match[0].length + offset;
                commentRange.push(Range);
            }
        }
        return commentRange;
    }
}
module.exports = vlogParser;

// test content
var text = vlogParser.preProcess("D:/project/Code/Javascript/HDLparser/test/verilog/parse.v");
console.log(text);