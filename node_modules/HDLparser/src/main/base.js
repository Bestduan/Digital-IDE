class baseParser {
    constructor() {

    }

    /**
     * @state finish-test
     * @descriptionCn 严格按照指定路径进行遍历树
     * @param {Object} tree 语法树
     * @param {Array}  path 遍历的路径(从当前树的下一级开始)
     * @returns {Object} ctx 目标节点
     */
    traverse_tree(tree, path) {
        let ctx = tree;
        for (let i = 0; i < path.length; i++) {
            const curIndex = path[i];

            if (!('children' in ctx)) {
                return false;
            }

            let isExist = false;
            let children = ctx.children;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child.ruleIndex == curIndex) {
                    ctx = child;
                    isExist = true;
                    break;
                }
            }

            if (!isExist) {
                return false;
            }
        }

        return ctx;
    }

    /**
     * @state finish-test
     * @descriptionCn 从当前语法树中递归找到所有满足的规则
     * @param {Object}  ctx   语法树
     * @param {Array}   index 所需要满足的规则序号
     */
    child_recursive(ctx, index, match) {
        if (ctx.ruleIndex == index) {
            match.push(ctx);
        }

        if (!('children' in ctx)) {
            return null;
        }

        
        let children = ctx.children;
        if (!children) {
            return null;
        }

        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            this.child_recursive(child, index, match);
        }
    }

    parent_traverse(ctx, index) {
        let tra_ctx = ctx.parentCtx;
        while (tra_ctx) {
            const curIndex = tra_ctx.ruleIndex;
            if (curIndex === index) {
                return tra_ctx;
            }
            tra_ctx = tra_ctx.parentCtx;
        }
        return false;
    }
}
module.exports = baseParser;