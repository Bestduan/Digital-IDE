const antlr4 = require("antlr4/index");

const vlogLexer = require("../../verilog/new/vlogLexer");
const vlogParser = require("../../verilog/new/vlogParser");
const vlogListener = require("../../verilog/new/vlogParserListener");

class vlogErrorListener extends antlr4.error.ErrorListener {
    constructor() {
        super();

        this.diags = [];
        return this;
    }
    syntaxError(offendingSymbol, postion, character, index, msg) {
        let diag = {};
        diag["severity"] = 1;
        diag["range"] = {
            start: { line: postion.line - 1, character: character },
            end: { line: postion.line - 1, character: character }
        };
        diag["message"] = `${index} : ${msg}`;
        diag["source"] = "Digital-IDE";
        this.diags.push(diag);
    }
}

class fastVisitor extends vlogListener.vlogParserListener {
    constructor() {
        super();

        this.modules = [];
        this.params = [];
        this.ports = [];
        this.instances = [];

        this.curModule = null;
        this.curInstance = null;
        this.errors = [];
    }

    /************ module ************* */

    exitModule_declaration(ctx) {
        let name = ctx.module_identifier();
        if (!name) {
            return null;
        }
        name = name.getText();

        let [...ports] = this.ports;
        let [...params] = this.params;
        let [...instances] = this.instances;
        this.curModule = {
            "includes"   : [],
            "languageId" : "verilog",
            'moduleName' : name,
            'modulePath' : null,
            'ports'      : ports,
            'params'     : params,
            "instances"  : instances,
            "start" : {
                line : ctx.start.line - 1,
                character : ctx.start.column,
            },
            "stop" : {
                line : ctx.stop.line - 1,
                character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
            }
        };
        this.ports = [];
        this.params = [];
        this.instances = [];
        this.modules.push(this.curModule);
    }

    /************ params ************* */
    enterParam_assignment(ctx) {
        let name = ctx.parameter_identifier();
        if (!name) {
            return null;
        }
        name = name.getText();

        let init = ctx.constant_mintypmax_expression();
        if (!init) {
            return null;
        }
        init = init.getText();

        let item = {
            "paramName"  : name,
            "paramInit"  : init,
        }
        this.params.push(item);
    }

    /************ ports ************* */
    get_port_info(ctx) {
        let range = ctx.range_();
        if (range) {
            range = range.getText();
        } else {
            return null;
        }

        let list = ctx.list_of_port_identifiers();
        if (!list) {
            list = ctx.list_of_variable_port_identifiers();
        }

        if (!list) {
            return null;
        }

        list = list.port_identifier();
        if (!list) {
            return null;
        }

        for (let i = 0; i < list.length; i++) {
            const port = list[i];
            let item = {
                "portName" : port.getText(),
                "portWidth": range,
            }
            this.ports.push(item);
        }
    }    

    enterInput_declaration(ctx) {
        this.get_port_info(ctx);
    }

    enterInout_declaration(ctx) {
        this.get_port_info(ctx);
    }

    enterOutput_declaration(ctx) {
        this.get_port_info(ctx);
    }

    /************ instantiation ************* */

    enterModule_instantiation(ctx) {
        let module = ctx.module_identifier();
        if (!module) {
            return null;
        }
        module = module.getText();

        this.curInstance = {
            "name": '',
            "type": "instance",
            "instparams": null,
            "instports" : null,
            "instName": '',         // name
            "instModule": module,   // module
            "instModPath": "",
        };

        let params = ctx.parameter_value_assignment();
        if (params) {
            params = params.list_of_parameter_assignments();
            this.curInstance.instparams = {
                start : {
                    line : params.start.line - 1,
                    character : params.start.column,
                },
                stop : {
                    line : params.stop.line - 1,
                    character : params.stop.column + params.stop.stop - params.stop.start + 1,
                }
            }
        }
    }

    enterModule_instance(ctx) {
        let name = ctx.name_of_module_instance();
        if (!name) {
            return null;
        }
        name = name.getText();

        this.curInstance.name = name;
        this.curInstance.instName = name;

        this.curInstance.start = {
            line : ctx.start.line - 1,
            character : ctx.start.column,
        };
        this.curInstance.stop = {
            line : ctx.stop.line - 1,
            character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
        };

        let ports = ctx.list_of_port_connections();
        if (ports) {
            this.curInstance.instports = {
                start : {
                    line : ports.start.line - 1,
                    character : ports.start.column,
                },
                stop : {
                    line : ports.stop.line - 1,
                    character : ports.stop.column + ports.stop.stop - ports.stop.start + 1,
                },
            }
        }
        this.instances.push(this.curInstance);
    }

    enterUdp_instantiation(ctx) {
        
    }

    enterUdp_instance(ctx) {
        
    }

    enterGate_instantiation(ctx) {

    }
}

class fsmVisitor extends vlogListener.vlogParserListener {
    constructor () {
        super();

        this.isAlways = false;
        this.state_name = null;
    }

    enterAlways_construct(ctx) {
        this.isAlways = true;
    }

    exitAlways_construct(ctx) {
        this.isAlways = false;
    }

    enterCase_statement(ctx) {
        if (!this.isAlways) {
            return null;
        }
        
        // 可能会导致递归
        if (!this.state_name) {
            this.state_name = ctx.expression().getText();
        }

        let state_items = ctx.case_item();
        for (let i = 0; i < state_items.length; i++) {
            const state_item = state_items[i];
            
        }
    }

    enterConditional_statement(ctx) {
        if (!this.isAlways) {
            return null;
        }
        
        // 条件与状态一一对应，如果多出来一个就说明是 else
        let conditions = ctx.expression();
        let state_items = ctx.statement_or_null();

        let len = state_items.length;
        for (let i = 0; i < len; i++) {
            const state_item = state_items[i].statement();
            if (!state_item) {
                continue;
            }

            this.getVariable(state_item);

            if (condition) {
                
            }
            const condition = conditions[i].getText();
        }
        
    }

    process_state_item(state_item) {


        // 如果是多个 item name 那么这些items是共用一个statement
        const item_names = state_item.expression();
        for (let i = 0; i < item_names.length; i++) {
            const name = item_names[i];
            let item = {}
            
        }
    }

    getVariable(statement) {
        let assigns = statement.nonblocking_assignment();
        let primary = assigns.variable_lvalue()
    }
}

class visitor extends vlogListener.vlogParserListener {
    constructor(option) {
        super();
        this.option = option;

        this.curInstance = null;
    }

    /************ module ************* */

    enterModule_declaration(ctx) {
        let name = ctx.module_identifier();
        if (!name) {
            return null;
        }
        name = name.getText();

        let item = {
            'name' : name,
            'type' : "module",
            'parent' : null,
            "start" : {
                line : ctx.start.line - 1,
                character : ctx.start.column,
            },
            "end" : {
                line : ctx.stop.line - 1,
                character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
            }
        };
        
        if (this.option.symbol) {
            this.option.symbol.setSymbolInfo(item);
        }
    }

    /************ function ************* */
    enterFunction_declaration(ctx) {
        let name = ctx.function_identifier();
        if (!name) {
            return null;
        }
        name = name.getText();

        let item = {
            'name' : name,
            'type' : "function",
            'parent' : null,
            "start" : {
                line : ctx.start.line - 1,
                character : ctx.start.column,
            },
            "end" : {
                line : ctx.stop.line - 1,
                character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
            }
        };
        if (this.option.symbol) {
            this.option.symbol.setSymbolInfo(item);
        }
    }

    /************ task ************* */
    enterTask_declaration(ctx) {
        let name = ctx.task_identifier();
        if (!name) {
            return null;
        }
        name = name.getText();

        let item = {
            'name' : name,
            'type' : "function",
            'parent' : null,
            "start" : {
                line : ctx.start.line - 1,
                character : ctx.start.column,
            },
            "end" : {
                line : ctx.stop.line - 1,
                character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
            }
        };
        if (this.option.symbol) {
            this.option.symbol.setSymbolInfo(item);
        }
    }

    enterTF_input_declaration(ctx) {
        this.process_port_info(ctx, 'input');
    }

    enterTF_inout_declaration(ctx) {
        this.process_port_info(ctx, 'inout');
    }

    enterTF_output_declaration(ctx) {
        this.process_port_info(ctx, 'output');
    }

    /************ (local)params ************* */
    enterParameter_declaration(ctx) {
        this.process_param_info(ctx, "parameter");
    }

    enterLocal_parameter_declaration(ctx) {
        this.process_param_info(ctx, "localparam");
    }

    process_param_info(ctx, type) {
        let params = [];
        // 342 : parameter_identifier
        this.child_recursive(ctx, 342, params);
        this.process_identifier(ctx, params, type);
    }

    /************ ports ************* */
    process_port_info(ctx, type) {
        let ports = [];
        // 343 : port_identifier
        this.child_recursive(ctx, 343, ports);
        this.process_identifier(ctx, ports, type);
    }    

    enterInput_declaration(ctx) {
        this.process_port_info(ctx, 'input');
    }

    enterInout_declaration(ctx) {
        this.process_port_info(ctx, 'inout');
    }

    enterOutput_declaration(ctx) {
        this.process_port_info(ctx, 'output');
    }

    /************ nets ************* */
    enterNet_declaration(ctx) {
        let nets = [];
        // 340 : net_identifier
        this.child_recursive(ctx, 340, nets);
        this.process_identifier(ctx, nets, 'net');
    }

    /************ regs ************* */
    enterReg_declaration(ctx) {
        let regs = [];
        // 355 : variable_identifier
        this.child_recursive(ctx, 355, regs);
        this.process_identifier(ctx, regs, 'reg');
    }

    /************ instantiation ************* */

    enterModule_instantiation(ctx) {
        let module = ctx.module_identifier();
        if (!module) {
            return null;
        }
        module = module.getText();

        this.curInstance = {
            "name": '',
            "type": "instance",
            "parent": null,
            "instparams": null,
            "instports" : null,
            "instName": '',         // name
            "instModule": module,   // module
            "instModPath": "",
        };

        let params = ctx.parameter_value_assignment();
        if (params) {
            params = params.list_of_parameter_assignments();
            this.curInstance.instparams = {
                start : {
                    line : params.start.line - 1,
                    character : params.start.column,
                },
                end : {
                    line : params.stop.line - 1,
                    character : params.stop.column + params.stop.stop - params.stop.start + 1,
                }
            }
        }
    }

    exitModule_instantiation(ctx) {
        this.curInstance = null;
    }

    enterModule_instance(ctx) {
        let name = ctx.name_of_module_instance();
        if(!name) {
            return null;
        }
        name = name.getText();

        this.curInstance.name = name;
        this.curInstance.instName = name;

        this.curInstance.start = {
            line : ctx.start.line - 1,
            character : ctx.start.column,
        };
        this.curInstance.end = {
            line : ctx.stop.line - 1,
            character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
        };

        let ports = ctx.list_of_port_connections();
        if (ports) {
            this.curInstance.instports = {
                start : {
                    line : ports.start.line - 1,
                    character : ports.start.column,
                },
                end : {
                    line : ports.stop.line - 1,
                    character : ports.stop.column + ports.stop.stop - ports.stop.start + 1,
                },
            }
        }
        
        if (this.option.symbol) {
            this.option.symbol.setSymbolInfo(this.curInstance);
        }
    }

    process_identifier(ctx, arr, type) {
        for (let i = 0; i < arr.length; i++) {
            const element = arr[i];
            let item = {
                'name'  : element.getText(),
                'type'  : type,
                'parent': null,
                'start' : {
                    line : ctx.start.line - 1,
                    character : ctx.start.column,
                },
                "end"   : {
                    line : ctx.stop.line - 1,
                    character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
                },
            }
            if (this.option.symbol) {
                this.option.symbol.setSymbolInfo(item);
            }
        }
    }

    /**
     * @state finish-test
     * @descriptionCn 从当前语法树中递归找到所有满足的规则
     * @param {Object}  ctx   语法树
     * @param {Number}   index 所需要满足的规则序号
     */
     child_recursive(ctx, index, match) {
        if (ctx.ruleIndex == index) {
            match.push(ctx);
        }

        if (!('children' in ctx)) {
            return null;
        }

        
        let children = ctx.children;
        if (!children) {
            return null;
        }

        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            this.child_recursive(child, index, match);
        }
    }
}

function parse(code) {
    const inputStream = new antlr4.InputStream(code);
    const lexer = new vlogLexer.vlogLexer(inputStream);

    lexer.removeErrorListeners();
    const errorListener = new vlogErrorListener();
    lexer.addErrorListener(errorListener);

    const tokenStream = new antlr4.CommonTokenStream(lexer);
    const parser = new vlogParser.vlogParser(tokenStream);
    parser.removeErrorListeners();
    parser.addErrorListener(errorListener);

    const ast = parser.parse();
    const errors = errorListener.diags;

    return {
        stream : tokenStream, 
        ast : ast, 
        err : errors 
    };
}

function walk(ast, visit) {
    antlr4.tree.ParseTreeWalker.DEFAULT.walk(visit, ast);
    return visit;
}

class parser {

    constructor () {
        this.path_str = /[\"\']\s*?(?<path>.+)\s*?[\"\']/;
        this.define = /`define\s+?(?<ID>[\\\$\w]+)\s*(\(.*?\)\s+)?(?<body>.+)/;
    }
    

    lint(code) {
        const parseResult = parse(code);
        return parseResult.err;
    }

    /**
     * @state unfinshed - untest
     * @descriptionCn 获取文件的详细属性
     * @param {Object} option   获取时需要操作的选项 
     * @param {Array}  HDLparam 在快解析模式下模块的详细属性存放的数组
     * @returns {Array}  HDLparam 
     */
    getFileParam(option, HDLparam) {
        try {
            // option是必须的
            if (!option) {
                return HDLparam;
            }
    
            const parseResult = parse(option.text);
            console.log(parseResult.err);
    
            // 仅定义为true时运行，null，false时均全运行
            if (option.isFast) { 
                var fastVisit = new fastVisitor();
                const walkResult = walk(parseResult.ast, fastVisit);

                let includes = this.getIncludes(parseResult.stream);
                
                for (let index = 0; index < walkResult.modules.length; index++) {
                    const module = walkResult.modules[index];
                    // 冗余包含文件引用，即每个模块均包含文件include
                    module.includes = includes;
                    module.modulePath = option.path;
                    HDLparam.push(module);
                }
    
                return HDLparam;
            }
    
            var visit = new visitor(option);
            walk(parseResult.ast, visit);
            // let defines = this.getDefine(parseResult.stream);
        }
        catch (error) {
            console.log(error);
            return HDLparam;
        }
    }

    getFSMParam() {
        try {
            const parseResult = parse(option.text);
            var visit = new fsmVisitor();
            const walkResult = walk(parseResult.ast, visit);
        }
        catch (error) {
            console.log(error);
            return null;
        }
    }

    getDefine(stream) {
        let defines = new Map();
        this.getChannel(stream, 3, (token) => {
            let content = token.text.match(this.define);
            let ID = content.groups.ID;
            let body = content.groups.body;

            if (ID) {
                defines.set(ID, body);
            }

        });
        return defines;
    }

    getIncludes(stream) {
        let includes = [];
        this.getChannel(stream, 4, (token) => {
            let path = token.text.match(this.path_str);
            path = path.groups.path;
            if (path) {
                includes.push(path);
            }
        });
        return includes;
    }

    getChannel(stream, number, callback) {
        let tokens = stream.tokens;
        let len = tokens.length;
        for (let i = 0; i < len; i++) {
            const token = tokens[i];
            if (token.channel !== number) {
                continue;
            }
            callback(token);
        }
    }
}
module.exports = parser;