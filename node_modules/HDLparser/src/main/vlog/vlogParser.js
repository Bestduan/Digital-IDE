const antlr4 = require("antlr4/index");
const filesys = require("HDLfilesys");
const vlogLexer = require("../../verilog/new/vlogLexer");
const vlogParser = require("../../verilog/new/vlogParser");
const vlogListener = require("../../verilog/new/vlogParserListener");

const base = require("../base");
const utils = require("../../../utils/utils");

class vlogErrorListener extends antlr4.error.ErrorListener {
    constructor() {
        super();

        this.diags = [];
        return this;
    }
    syntaxError(offendingSymbol, postion, character, index, msg) {
        let diag = {};
        diag["severity"] = 0;
        diag["range"] = {
            start: { line: postion.line - 1, character: character },
            end: { line: postion.line - 1, character: character }
        };
        diag["message"] = `${index} : ${msg}`;
        diag["source"] = "Digital-IDE";
        this.diags.push(diag);
    }
}

class fastVisitor extends vlogListener.vlogParserListener {
    constructor() {
        super();

        this.modules = [];
        this.params = [];
        this.ports = [];
        this.instances = [];

        this.curModule = null;
        this.curInstance = null;
        
        this.base = new base();
    }

    /************ module ************* */

    exitModule_declaration(ctx) {
        let name = ctx.module_identifier();
        if (!name) {
            return null;
        }
        name = name.getText();

        let [...ports] = this.ports;
        let [...params] = this.params;
        let [...instances] = this.instances;
        this.curModule = {
            "includes"   : [],
            "languageId" : "verilog",
            'moduleName' : name,
            'modulePath' : null,
            'ports'      : ports,
            'params'     : params,
            "instances"  : instances,
            "start" : {
                line : ctx.start.line - 1,
                character : ctx.start.column,
            },
            "end" : {
                line : ctx.stop.line - 1,
                character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
            }
        };
        this.ports = [];
        this.params = [];
        this.instances = [];
        this.modules.push(this.curModule);
    }

    /************ params ************* */
    enterParameter_declaration(ctx) {
        let params = [];

        // 66 : param_assignment
        this.base.child_recursive(ctx, 66, params);
        for (let i = 0; i < params.length; i++) {
            const param = params[i];
            let name = param.parameter_identifier();
            if (!name) {
                continue;
            }
            name = name.getText();

            let expression = param.constant_mintypmax_expression();
            if (!expression) {
                continue;
            }
            expression = expression.getText();
            let item = {
                "name" : name,
                "paramName" : name,
                "paramInit" : expression,
                "start" : {
                    line : ctx.start.line - 1,
                    character : ctx.start.column,
                },
                "end" : {
                    line : ctx.stop.line - 1,
                    character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
                }
            }
            this.params.push(item); 
        }
    }

    /************ ports ************* */
    get_port_info(ctx, type) {
        let range = ctx.range_();
        range = range ? range.getText() : '';

        let ports = [];
        // 343 : port_identifier
        this.base.child_recursive(ctx, 343, ports);
        for (let i = 0; i < ports.length; i++) {
            const port = ports[i];
            const name = port.getText();
            let item = {
                "name" : name,
                "type" : type,
                "portName" : name,
                "portWidth": range,
                "start" : {
                    line : ctx.start.line - 1,
                    character : ctx.start.column,
                },
                "end" : {
                    line : ctx.stop.line - 1,
                    character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
                }
            }
            this.ports.push(item);
        }
    }    

    enterInput_declaration(ctx) {
        this.get_port_info(ctx, 'input');
    }

    enterInout_declaration(ctx) {
        this.get_port_info(ctx, 'inout');
    }

    enterOutput_declaration(ctx) {
        this.get_port_info(ctx, 'output');
    }

    /************ instantiation ************* */

    enterModule_instantiation(ctx) {
        let module = ctx.module_identifier();
        if (!module) {
            return null;
        }
        module = module.getText();

        this.curInstance = {
            "name": '',
            "type": "instance",
            "instparams": null,
            "instports" : null,
            "instName": '',         // name
            "instModule": module,   // module
            "instModPath": "",
        };

        let params = ctx.parameter_value_assignment();
        if (params) {
            params = params.list_of_parameter_assignments();
            this.curInstance.instparams = {
                start : {
                    line : params.start.line - 1,
                    character : params.start.column,
                },
                stop : {
                    line : params.stop.line - 1,
                    character : params.stop.column + params.stop.stop - params.stop.start + 1,
                }
            }
        }
    }

    enterModule_instance(ctx) {
        let name = ctx.name_of_module_instance();
        if (!name) {
            return null;
        }
        name = name.getText();

        this.curInstance.name = name;
        this.curInstance.instName = name;

        this.curInstance.start = {
            line : ctx.start.line - 1,
            character : ctx.start.column,
        };
        this.curInstance.stop = {
            line : ctx.stop.line - 1,
            character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
        };

        let ports = ctx.list_of_port_connections();
        if (ports) {
            this.curInstance.instports = {
                start : {
                    line : ports.start.line - 1,
                    character : ports.start.column,
                },
                stop : {
                    line : ports.stop.line - 1,
                    character : ports.stop.column + ports.stop.stop - ports.stop.start + 1,
                },
            }
        }
        this.instances.push(this.curInstance);
    }

    enterUdp_instantiation(ctx) {}

    enterUdp_instance(ctx) {}

    enterGate_instantiation(ctx) {}
}

class fsmVisitor extends vlogListener.vlogParserListener {
    constructor () {
        super();

        this.base = new base();
    }

    enterAlways_construct(ctx) {

        let case_items = [];
        // 190 : case_statement
        this.base.child_recursive(ctx, 190, case_items);
        if(!case_items.length) {
            return null;
        }

        // case_items 的第一个是最外层的
        let state_name = case_items[0].expression().getText();
        let state_items = ctx.case_item();
        for (let i = 0; i < state_items.length; i++) {
            const state_item = state_items[i];
            
        }
    }
}

class visitor extends vlogListener.vlogParserListener {
    constructor(option) {
        super();
        this.option = option;

        this.curInstance = null;
        this.base = new base();
    }

    /************ module ************* */

    enterModule_declaration(ctx) {
        let name = ctx.module_identifier();
        if (!name) {
            return null;
        }
        name = name.getText();

        let item = {
            'name' : name,
            'type' : "module",
            'parent' : null,
            "start" : {
                line : ctx.start.line - 1,
                character : ctx.start.column,
            },
            "end" : {
                line : ctx.stop.line - 1,
                character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
            }
        };
        
        if (this.option.symbol) {
            this.option.symbol.setSymbolInfo(item);
        }
    }

    /************ function ************* */
    enterFunction_declaration(ctx) {
        let name = ctx.function_identifier();
        if (!name) {
            return null;
        }
        name = name.getText();

        let item = {
            'name' : name,
            'type' : "function",
            'parent' : null,
            "start" : {
                line : ctx.start.line - 1,
                character : ctx.start.column,
            },
            "end" : {
                line : ctx.stop.line - 1,
                character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
            }
        };
        if (this.option.symbol) {
            this.option.symbol.setSymbolInfo(item);
        }
    }

    /************ task ************* */
    enterTask_declaration(ctx) {
        let name = ctx.task_identifier();
        if (!name) {
            return null;
        }
        name = name.getText();

        let item = {
            'name' : name,
            'type' : "function",
            'parent' : null,
            "start" : {
                line : ctx.start.line - 1,
                character : ctx.start.column,
            },
            "end" : {
                line : ctx.stop.line - 1,
                character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
            }
        };
        if (this.option.symbol) {
            this.option.symbol.setSymbolInfo(item);
        }
    }

    enterTF_input_declaration(ctx) {
        this.process_port_info(ctx, 'input');
    }

    enterTF_inout_declaration(ctx) {
        this.process_port_info(ctx, 'inout');
    }

    enterTF_output_declaration(ctx) {
        this.process_port_info(ctx, 'output');
    }

    /************ (local)params ************* */
    enterParameter_declaration(ctx) {
        this.process_param_info(ctx, "parameter");
    }

    enterLocal_parameter_declaration(ctx) {
        this.process_param_info(ctx, "localparam");
    }

    process_param_info(ctx, type) {
        let params = [];
        // 342 : parameter_identifier
        this.base.child_recursive(ctx, 342, params);
        this.process_identifier(ctx, params, type);
    }

    /************ ports ************* */
    process_port_info(ctx, type) {
        let ports = [];
        // 343 : port_identifier
        this.base.child_recursive(ctx, 343, ports);
        this.process_identifier(ctx, ports, type);
    }    

    enterInput_declaration(ctx) {
        this.process_port_info(ctx, 'input');
    }

    enterInout_declaration(ctx) {
        this.process_port_info(ctx, 'inout');
    }

    enterOutput_declaration(ctx) {
        this.process_port_info(ctx, 'output');
    }

    /************ nets ************* */
    enterNet_declaration(ctx) {
        let nets = [];
        // 340 : net_identifier
        this.base.child_recursive(ctx, 340, nets);
        this.process_identifier(ctx, nets, 'net');
    }

    /************ regs ************* */
    enterReg_declaration(ctx) {
        let regs = [];
        // 355 : variable_identifier
        this.base.child_recursive(ctx, 355, regs);
        this.process_identifier(ctx, regs, 'reg');
    }

    /************ instantiation ************* */

    enterModule_instantiation(ctx) {
        let module = ctx.module_identifier();
        if (!module) {
            return null;
        }
        module = module.getText();

        this.curInstance = {
            "name": '',
            "type": "instance",
            "parent": null,
            "instparams": null,
            "instports" : null,
            "instName": '',         // name
            "instModule": module,   // module
            "instModPath": "",
        };

        this.curInstance.start = {
            line : ctx.start.line - 1,
            character : ctx.start.column,
        };
        this.curInstance.end = {
            line : ctx.stop.line - 1,
            character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
        };

        let params = ctx.parameter_value_assignment();
        if (params) {
            params = params.list_of_parameter_assignments();
            this.curInstance.instparams = {
                start : {
                    line : params.start.line - 1,
                    character : params.start.column,
                },
                end : {
                    line : params.stop.line - 1,
                    character : params.stop.column + params.stop.stop - params.stop.start + 1,
                }
            }
        }
    }

    exitModule_instantiation(ctx) {
        this.curInstance = null;
    }

    enterModule_instance(ctx) {
        let name = ctx.name_of_module_instance();
        if(!name) {
            return null;
        }
        name = name.getText();

        this.curInstance.name = name;
        this.curInstance.instName = name;
        let ports = ctx.list_of_port_connections();
        if (ports) {
            this.curInstance.instports = {
                start : {
                    line : ports.start.line - 1,
                    character : ports.start.column,
                },
                end : {
                    line : ports.stop.line - 1,
                    character : ports.stop.column + ports.stop.stop - ports.stop.start + 1,
                },
            }
        }
        
        if (this.option.symbol) {
            this.option.symbol.setSymbolInfo(this.curInstance);
        }
    }

    process_identifier(ctx, arr, type) {
        for (let i = 0; i < arr.length; i++) {
            const element = arr[i];
            let item = {
                'name'  : element.getText(),
                'type'  : type,
                'parent': null,
                'start' : {
                    line : ctx.start.line - 1,
                    character : ctx.start.column,
                },
                "end"   : {
                    line : ctx.stop.line - 1,
                    character : ctx.stop.column + ctx.stop.stop - ctx.stop.start + 1,
                },
            }
            if (this.option.symbol) {
                this.option.symbol.setSymbolInfo(item);
            }
        }
    }
}

class parser {

    constructor () {
        this.l_comment = /\/\/.*/mg;
        this.b_comment = /\/\*[\s\S]*?\*\//mg;
        this.path_str = /[\"\']\s*(?<path>.+)\s*[\"\']/;
        this.define = /`define\s+?(?<ID>[\\\$\w]+)\s*(\(.*?\)\s+)?(?<body>.+)/g;
        this.include = /`include\s*[\"\']\s*(?<path>.+)\s*[\"\']/g;

        this.illegalMatches = /(?!\breturn\b|\bbegin\b|\bend\b|\belse\b|\bjoin\b|\bfork\b|\bfor\b|\bif\b|\bvirtual\b|\bstatic\b|\bautomatic\b|\bgenerate\b|\bassign\b|\binitial\b|\bassert\b|\bdisable\b)/;

        this.comment = /(?:\/\/.*$)?/;

        this.instances = new RegExp([
            // '(?<=^\\s*',
            // /(?:(?<modifier>virtual|static|automatic|rand|randc|pure virtual)\s+)?/,
            // this.illegalMatches,
            // /\b(?<type>[:\w]+(?:\s*\[[^\]]*?\])*?)\s*/,
            // this.comment,
            // /(?<params>#\s*\([\w\W]*?\))?\s*/,
            // /(\b\w+\s*,\s*)*?/,
            // ')',
            // this.illegalMatches,
            // /\b(?<name>\w+)\s*/,
            // /(?<ports>(\[[^\]]*?\]\s*)*?|(\([\w\W]*?\))?)\s*/,
            // /\s*(;|,|=)/
            /(?<type>[\\\$\w]+)\s*/,
            /(#\s*\(\s*(?<params>\.[\w\W]*?)?\))?\s*/,
            /(?<name>[\\\$\w]+)\s*/,
            /(\(\s*(?<ports>\.[\w\W]*?)\)\s*;)/,
        ].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');
    }

    parse(code) {
        const inputStream = new antlr4.InputStream(code);
        const lexer = new vlogLexer.vlogLexer(inputStream);
    
        lexer.removeErrorListeners();
        const errorListener = new vlogErrorListener();
        lexer.addErrorListener(errorListener);
    
        const tokenStream = new antlr4.CommonTokenStream(lexer);
        const parser = new vlogParser.vlogParser(tokenStream);
        parser.removeErrorListeners();
        parser.addErrorListener(errorListener);
    
        const ast = parser.parse();
        const errors = errorListener.diags;
    
        return {
            stream : tokenStream, 
            ast : ast, 
            err : errors 
        };
    }

    walk(ast, visit) {
        antlr4.tree.ParseTreeWalker.DEFAULT.walk(visit, ast);
        return visit;
    }

    lint(code) {
        const parseResult = this.parse(code);
        return parseResult.err;
    }

    /**
     * @state unfinshed - untest
     * @descriptionCn 获取文件的详细属性
     * @param {Object} option   获取时需要操作的选项 
     * @param {Array}  HDLparam 在快解析模式下模块的详细属性存放的数组
     * @returns {Array}  HDLparam 
     */
    getFileParam(option, HDLparam) {
        try {
            // option是必须的
            if (!option) {
                return HDLparam;
            }
    
            const parseResult = this.parse(option.text);
            // console.log(parseResult.err);
    
            // 仅定义为true时运行，null，false时均全运行
            if (option.isFast) { 
                var fastVisit = new fastVisitor();
                const walkResult = this.walk(parseResult.ast, fastVisit);

                let includes = this.getIncludes(parseResult.stream, option.path);
                
                for (let index = 0; index < walkResult.modules.length; index++) {
                    const module = walkResult.modules[index];
                    // 冗余包含文件引用，即每个模块均包含文件include
                    module.includes = includes;
                    module.modulePath = option.path;
                    HDLparam.push(module);
                }
    
                return HDLparam;
            }
    
            var visit = new visitor(option);
            this.walk(parseResult.ast, visit);
        }
        catch (error) {
            console.log(error);
            return HDLparam;
        }
    }

    getFSMParam() {
        try {
            const parseResult = this.parse(option.text);
            var visit = new fsmVisitor();
            const walkResult = this.walk(parseResult.ast, visit);
        }
        catch (error) {
            console.log(error);
            return null;
        }
    }

    getIncludes(stream, curPath) {
        let includes = [];
        this.getChannel(stream, 4, (token) => {
            let path = token.text.match(this.path_str);
            if (curPath) {
                path = filesys.paths.rel2abs(curPath, path.groups.path);
            }
            if (path) {
                includes.push(path);
            }
        });
        return includes;
    }

    getChannel(stream, number, callback) {
        let tokens = stream.tokens;
        let len = tokens.length;
        for (let i = 0; i < len; i++) {
            const token = tokens[i];
            if (token.channel !== number) {
                continue;
            }
            callback(token);
        }
    }

    /**
     * @state finish - untested
     * @descriptionCn Verilog源代码中例化模块的检测
     * @param {Object} text    输入内容
     * @return {Array} items   例化模块的详细相关属性组
     */
    get_instances(text) {
        let items = [];
        while (1) {
            let match = this.instances.exec(text);
            if (match == null) {
                break;      
            }

            if (match.groups.type == "module") {
                continue;
            }
    
            let item = {
                "instparams": {
                    "startIndex": -1,
                    "lastIndex" : -1,
                },
                "instports" : {
                    "startIndex": -1,
                    "lastIndex" : -1,
                },
                "instName": match.groups.name,   // name
                "instModule": match.groups.type, // type
                "startIndex": match.index,
                "lastIndex" : match.index + match[0].length,
            };

            if (match.groups.params != null) {
                item.instparams.startIndex = match.index + match[0].indexOf(match.groups.params);
                item.instparams.lastIndex = item.instparams.startIndex + match.groups.params.length;
            }
            if (match.groups.ports != null) {
                item.instports.startIndex = match.index + match[0].indexOf(match.groups.ports);
                item.instports.lastIndex = item.instports.startIndex + match.groups.ports.length;
            }
            items.push(item);
        }
        return items;
    }

    /**
     * @state finish - tested
     * @descriptionCn 获取宏定义内容
     * @param {String} path 源文件路径
     * @param {Map} defines 宏定义的键与值 key : macro_name value : macro_content
     * @returns null
     */
    get_define(text, path, defines) {
        text = this.del_comments(text);

        // 获取本文件中的所有define宏定义
        while (1) {
            let match = this.define.exec(text);
            if (match == null) {
                break;      
            }
            if (!match.groups.ID) {
                continue;
            }
            if (!match.groups.body) {
                continue;
            }
            // note : define是唯一对应的，后面定义的会将前面的冲掉
            let value = {
                path : path,
                body : match.groups.body,
                startIndex : match.index,
                lastIndex : match.index + match[0].length,
            }
            let range = utils.index_to_range(text, value);
            value.start = range.start;
            value.end = range.end;
            defines.set(match.groups.ID, value);
        }

        // 主要是针对 `include 里的define宏定义的情况
        let newText = text;
        defines.forEach((value, key) => {
            let regExp = new RegExp(`(?<!\\w)\`${key}(?!\\w)`, 'mg');
            newText = newText.replace(regExp, value);
        });

        let includes = this.get_include(newText, path);
        for (let i = 0; i < includes.length; i++) {
            const path = includes[i];
            const text = filesys.files.readFile(path);
            if (!text) {
                continue;
            }
            this.get_define(text, path, defines);
        }
        return defines;
    }

    /**
     * @state finish - tested
     * @descriptionCn 获取Verilog代码中的include语句并将其转化成绝对路径
     * @param {String} text verilog content after deleting all comment content
     * @param {String} curPath current verilog path
     * @returns {Array} An array of absolute path included in this verilog code
     */
    get_include(text, curPath) {
        let items = [];
        while (1) {
            let match = this.include.exec(text);
            if (match == null) {
                break;      
            }
            let path = match.groups.path;
            if (curPath) {
                path = filesys.paths.rel2abs(curPath, path);
            }
            if (path) {
                items.push(path);
            }
        }
        return items;
    }

    /**
     * @state finish - tested
     * @descriptionCn 将文本中的注释全部去掉保留换行
     * @descriptionEn delete all comment form verilog code
     * @param {String} text Verilog code input
     * @returns Verilog code output after deleting all comment content
     */
    del_comments(text) {
        let match = text.match(this.b_comment);
        if (match != null) {
            for (let i = 0; i < match.length; i++) {
                const element = match[i];
                const newElement = element.replace(/\S/g, ' ');
                text = text.replace(element,newElement);
            }
        }
        match = text.match(this.l_comment);
        if (match != null) {
            for (let i = 0; i < match.length; i++) {
                const element = match[i];
                const newElement = element.replace(/\S/g, ' ');
                text = text.replace(element,newElement);
            }
        }
        return text;
    }

    /**
     * @state finish - tested
     * @descriptionCn 获取Verilog代码中的注释范围
     * @param {String} text   Verilog代码文本
     * @param {Number} offset text文本在整个代码段中的偏移
     * @returns 由注释范围对象所组成的数组
     */
    get_comment_index(text, offset) {
        let commentIndex = [];
        let commentRegExps = [this.b_comment, this.l_comment];
        for (let i = 0; i < commentRegExps.length; i++) {
            while (1) {
                let match = commentRegExps[i].exec(text);
                if (match == null) {
                    break;
                }
                let index = {
                    "startIndex" : 0,
                    "lastIndex"  : 0
                }
                index.startIndex = match.index + offset ? offset : 0;
                index.lastIndex = match.index + match[0].length + offset ? offset : 0;
                commentIndex.push(index);
            }
        }
        return commentIndex;
    }
}
module.exports = parser;