const antlr4 = require("antlr4/index");

const svlogLexer = require("../../systemverilog/new/svlogLexer");
const svlogParser = require("../../systemverilog/new/svlogParser");
const svlogListener = require("../../systemverilog/new/svlogParserListener");

class svlogErrorListener extends antlr4.error.ErrorListener {
    constructor() {
        super();

        this.diags = [];
        return this;
    }
    syntaxError(offendingSymbol, postion, character, index, msg) {
        let diag = {};
        diag["severity"] = 1;
        diag["range"] = {
            start: { line: postion.line - 1, character: character },
            end: { line: postion.line - 1, character: character }
        };
        diag["message"] = `${index} : ${msg}`;
        diag["source"] = "Digital-IDE";
        this.diags.push(diag);
    }
}

class fastVisitor extends svlogListener.svlogParserListener {
    constructor() {
        super();

        this.modules = [];
        this.params = [];
        this.ports = [];
        this.instances = [];

        this.curModule = null;
        this.curInstance = null;
    }

    /************ module ************* */

    exitModule_declaration(ctx) {
        let name = ctx.module_nonansi_header();
        name = ctx.module_identifier();
        if (!name) {
            return null;
        }
        name = name.getText();

        let [...ports] = this.ports;
        let [...params] = this.params;
        let [...instances] = this.instances;
        this.curModule = {
            "includes"   : null,
            "languageId" : "verilog",
            'moduleName' : name,
            'modulePath' : null,
            'ports'      : ports,
            'params'     : params,
            "instances"  : instances,
            "start" : {
                line : ctx.start.line - 1,
                character : ctx.start.column,
            },
            "stop" : {
                line : ctx.stop.line - 1,
                character : ctx.stop.column,
            }
        };
        this.ports = [];
        this.params = [];
        this.instances = [];
        this.modules.push(this.curModule);
    }
}

class fsmVisitor extends svlogListener.svlogParserListener {
    constructor () {
        super();

        this.isAlways = false;
        this.state_name = null;
    }

    enterAlways_construct(ctx) {
        this.isAlways = true;
    }

    exitAlways_construct(ctx) {
        this.isAlways = false;
    }

    enterCase_statement(ctx) {
        if (!this.isAlways) {
            return null;
        }
        
        // 可能会导致递归
        if (!this.state_name) {
            this.state_name = ctx.expression().getText();
        }

        let state_items = ctx.case_item();
        for (let i = 0; i < state_items.length; i++) {
            const state_item = state_items[i];
            
        }
    }

    enterConditional_statement(ctx) {
        if (!this.isAlways) {
            return null;
        }
        
        // 条件与状态一一对应，如果多出来一个就说明是 else
        let conditions = ctx.expression();
        let state_items = ctx.statement_or_null();

        let len = state_items.length;
        for (let i = 0; i < len; i++) {
            const state_item = state_items[i].statement();
            if (!state_item) {
                continue;
            }

            this.getVariable(state_item);

            if (condition) {
                
            }
            const condition = conditions[i].getText();
        }
        
    }

    process_state_item(state_item) {


        // 如果是多个 item name 那么这些items是共用一个statement
        const item_names = state_item.expression();
        for (let i = 0; i < item_names.length; i++) {
            const name = item_names[i];
            let item = {}
            
        }
    }

    getVariable(statement) {
        let assigns = statement.nonblocking_assignment();
        let primary = assigns.variable_lvalue()
    }
}

class visitor extends svlogListener.svlogParserListener {
    constructor(option) {
        super();
        this.option = option;
        
        this.curParent = null;
        this.curInstance = null;

        this.errors = [];
    }

    /************ module ************* */

    enterModule_declaration(ctx) {
        let name = ctx.module_identifier().getText();
        let item = {
            'name' : name,
            'type' : "module",
            'parent' : null,
            "start" : {
                line : ctx.start.line - 1,
                character : ctx.start.column,
            },
            "end" : {
                line : ctx.stop.line - 1,
                character : ctx.stop.column,
            }
        };

        this.curParent = name;
        
        if (this.option.symbol) {
            this.option.symbol.setSymbolInfo(item);
        }
    }

    /************ function ************* */
    enterFunction_declaration(ctx) {
        let name = ctx.function_identifier().getText();
        let item = {
            'name' : name,
            'type' : "function",
            'parent' : this.curParent,
            "start" : {
                line : ctx.start.line - 1,
                character : ctx.start.column,
            },
            "end" : {
                line : ctx.stop.line - 1,
                character : ctx.stop.column,
            }
        };
        this.curParent = name;
        if (this.option.symbol) {
            this.option.symbol.setSymbolInfo(item);
        }
    }

    exitFunction_declaration(ctx) {
        //TODO: curParent多级检索
    }

    /************ task ************* */
    enterTask_declaration(ctx) {
        let name = ctx.task_identifier().getText();
        let item = {
            'name' : name,
            'type' : "function",
            'parent' : this.curParent,
            "start" : {
                line : ctx.start.line - 1,
                character : ctx.start.column,
            },
            "end" : {
                line : ctx.stop.line - 1,
                character : ctx.stop.column,
            }
        };
        this.curParent = name;
        if (this.option.symbol) {
            this.option.symbol.setSymbolInfo(item);
        }
    }

    exitTask_declaration(ctx) {
        //TODO: curParent多级检索
    }

    /************ (local)params ************* */
    enterParameter_declaration(ctx) {
        this.process_param_info(ctx, "parameter");
    }

    enterLocal_parameter_declaration(ctx) {
        this.process_param_info(ctx, "localparam");
    }

    process_param_info(ctx, type) {
        let params = ctx.list_of_param_assignments();

        params = params.children;

        for (let i = 0; i < params.length; i++) {
            const param = params[i];
            let item = {
                'name'  : param.parameter_identifier().getText(),
                'type'  : type,
                'parent': this.curParent,
                'start' : {
                    line : ctx.start.line - 1,
                    character : ctx.start.column,
                },
                "end"   : {
                    line : ctx.stop.line - 1,
                    character : ctx.stop.column,
                },
            }
            if (this.option.symbol) {
                this.option.symbol.setSymbolInfo(item);
            }
        }
    }

    /************ ports ************* */
    process_port_info(ctx, type) {
        let range = ctx.range_();
        if (range) {
            range = range.getText();
        }

        let list = ctx.list_of_port_identifiers();
        if (!list) {
            list = ctx.list_of_variable_port_identifiers();
        }

        list = list.port_identifier();

        for (let i = 0; i < list.length; i++) {
            const port = list[i];
            let item = {
                'name'  : port.getText(),
                'type'  : type,
                'parent': this.curParent,
                'start' : {
                    line : ctx.start.line - 1,
                    character : ctx.start.column,
                },
                "end"   : {
                    line : ctx.stop.line - 1,
                    character : ctx.stop.column,
                },
            }
            if (this.option.symbol) {
                this.option.symbol.setSymbolInfo(item);
            }
        }
    }    

    enterInput_declaration(ctx) {
        this.process_port_info(ctx, 'input');
    }

    enterInout_declaration(ctx) {
        this.process_port_info(ctx, 'inout');
    }

    enterOutput_declaration(ctx) {
        this.process_port_info(ctx, 'output');
    }

    /************ nets ************* */

    enterNet_declaration(ctx) {
        let nets = ctx.list_of_net_identifiers();
        if (nets) {
            this.process_nets_info(ctx, nets);
        } else {
            nets = ctx.list_of_net_decl_assignments();
            this.process_nets_assign_info(ctx, nets);
        }
    }

    process_nets_assign_info(ctx, nets) {
        nets = nets.children;
        for (let i = 0; i < nets.length; i++) {
            const net = nets[i];
            let item = {
                'name'  : net.net_identifier().getText(),
                'type'  : 'net',
                'parent': this.curParent,
                'start' : {
                    line : ctx.start.line - 1,
                    character : ctx.start.column,
                },
                "end"   : {
                    line : ctx.stop.line - 1,
                    character : ctx.stop.column,
                },
            }
            if (this.option.symbol) {
                this.option.symbol.setSymbolInfo(item);
            }
        }
    }

    process_nets_info(ctx, nets) {
        nets = nets.children;
        for (let i = 0; i < nets.length; i++) {
            const net = nets[i];
            let item = {
                'name'  : net.getText(),
                'type'  : 'net',
                'parent': this.curParent,
                'start' : {
                    line : ctx.start.line - 1,
                    character : ctx.start.column,
                },
                "end"   : {
                    line : ctx.stop.line - 1,
                    character : ctx.stop.column,
                },
            }
            if (this.option.symbol) {
                this.option.symbol.setSymbolInfo(item);
            }
        }
    }

    /************ instantiation ************* */

    enterModule_instantiation(ctx) {
        let module = ctx.module_identifier().getText();

        this.curInstance = {
            "name": '',
            "type": "instance",
            "instparams": null,
            "instports" : null,
            "instName": '',         // name
            "instModule": module,   // module
            "instModPath": "",
        };

        let params = ctx.parameter_value_assignment();
        if (params) {
            params = params.list_of_parameter_assignments();
            this.curInstance.instparams = {
                start : {
                    line : params.start.line,
                    character : params.start.column,
                },
                end : {
                    line : params.stop.line,
                    character : params.stop.column,
                }
            }
        }
    }

    enterModule_instance(ctx) {
        let name = ctx.name_of_module_instance().getText();
        this.curInstance.name = name;
        this.curInstance.instName = name;

        this.curInstance.start = {
            line : ctx.start.line - 1,
            character : ctx.start.column,
        };
        this.curInstance.end = {
            line : ctx.stop.line - 1,
            character : ctx.stop.column,
        };

        let ports = ctx.list_of_port_connections();
        if (ports) {
            this.curInstance.instports = {
                start : {
                    line : ports.start.line,
                    character : ports.start.column,
                },
                end : {
                    line : ports.stop.line,
                    character : ports.stop.column,
                },
            }
        }
        
        if (this.option.symbol) {
            this.option.symbol.setSymbolInfo(this.curInstance);
        }
        this.curInstance = null;
    }
}

function parse(code) {
    const inputStream = new antlr4.InputStream(code);
    const lexer = new svlogLexer.svlogLexer(inputStream);

    lexer.removeErrorListeners();
    const errorListener = new svlogErrorListener();
    lexer.addErrorListener(errorListener);

    const tokenStream = new antlr4.CommonTokenStream(lexer);
    const parser = new svlogParser.svlogParser(tokenStream);
    parser.removeErrorListeners();
    parser.addErrorListener(errorListener);

    const ast = parser.parse();
    const errors = errorListener.errors;

    return {
        stream : tokenStream, 
        ast : ast, 
        err : errors 
    };
}

function walk(ast, visit) {
    antlr4.tree.ParseTreeWalker.DEFAULT.walk(visit, ast);
    return visit;
}


var parser = {
    
    path_str : /[\"\']\s*?(?<path>.+)\s*?[\"\']/,

    define : /`define\s+?(?<ID>[\\\$\w]+)\s*(\(.*?\)\s+)?(?<body>.+)/,

    /**
     * @state unfinshed - untest
     * @descriptionCn 获取文件的详细属性
     * @param {Object} option   获取时需要操作的选项 
     * @param {Array}  HDLparam 在快解析模式下模块的详细属性存放的数组
     * @returns {Array}  HDLparam 
     */
    getFileParam : function (option, HDLparam) {
        try {
            // option是必须的
            if (!option) {
                return HDLparam;
            }
    
            const parseResult = parse(option.text);
    
            // 仅定义为true时运行，null，false时均全运行
            if (option.isFast) { 
                var fastVisit = new fastVisitor();
                const walkResult = walk(parseResult.ast, fastVisit);

                let includes = this.getIncludes(parseResult.stream);
                
                for (let index = 0; index < walkResult.modules.length; index++) {
                    const module = walkResult.modules[index];
                    // 冗余包含文件引用，即每个模块均包含文件include
                    module.includes = includes;
                    module.modulePath = option.path;
                    HDLparam.push(module);
                }
    
                return HDLparam;
            }
    
            var visit = new visitor(option.path);
            let defines = this.getDefine(parseResult.stream);
            const walkResult = walk(parseResult.ast, visit);
            for (let index = 0; index < walkResult.modules.length; index++) {
                const module = walkResult.modules[index];
            }
    
            return HDLparam;
        }
        catch (error) {
            console.log(error);
            return HDLparam;
        }
    },

    getFSMParam : function () {
        try {
            const parseResult = parse(option.text);
            var visit = new fsmVisitor();
            const walkResult = walk(parseResult.ast, visit);
        }
        catch (error) {
            console.log(error);
            return null;
        }
    },

    getDefine : function (stream) {
        let defines = new Map();
        this.getChannel(stream, 3, (token) => {
            let content = token.text.match(this.define);
            let ID = content.groups.ID;
            let body = content.groups.body;

            if (ID) {
                defines.set(ID, body);
            }

        });
        return defines;
    },

    getIncludes : function (stream) {
        let includes = [];
        this.getChannel(stream, 4, (token) => {
            let path = token.text.match(this.path_str);
            path = path.groups.path;
            if (path) {
                includes.push(path);
            }
        });
        return includes;
    },

    getChannel : function (stream, number, callback) {
        let tokens = stream.tokens;
        let len = tokens.length;
        for (let i = 0; i < len; i++) {
            const token = tokens[i];
            if (token.channel !== number) {
                continue;
            }
            callback(token);
        }
    },
}

const fs = require("fs");
const filesys = require("HDLfilesys");
//const test_path = "D:/project/Code/.prj/Extension/Owner/DIDE/lib/src_lib/Hardware/Math/Cordic.v"
// const test_path = "D:/project/Code/Javascript/HDLparser/test/vlog/statemac_test.v"
const test_path = "D:/project/Code/Javascript/HDLparser/test/vlog/instance_test.v";
let text = fs.readFileSync(test_path, "utf-8");
let option = {
    text : text,
    path : test_path,
    isFast : true,
}
let HDLparam = [];
// parser.getFSMParam();
parser.getFileParam(option, HDLparam);
// console.log(HDLparam);