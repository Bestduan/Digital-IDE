const antlr4 = require("antlr4/index");

const vhdlLexer = require("../../vhdl/vhdlLexer");
const vhdlParser = require("../../vhdl/vhdlParser");
const vhdlListener = require("../../vhdl/vhdlListener");

const base = require("../base");

class vhdlErrorListener extends antlr4.error.ErrorListener {
    constructor() {
        super();

        this.diags = [];
        return this;
    }
    syntaxError(offendingSymbol, postion, character, index, msg) {
        let diag = {};
        diag["severity"] = 1;
        diag["range"] = {
            start: { line: postion.line - 1, character: character },
            end: { line: postion.line - 1, character: character }
        };
        diag["message"] = `${index} : ${msg}`;
        diag["source"] = "Digital-IDE";
        this.diags.push(diag);
    }
}

class fastVisitor extends vhdlListener.vhdlListener {
    constructor() {
        super();

        this.modules = [];
        this.params = [];
        this.ports = [];
        this.instances = [];

        this.curModule = null;
        this.base = new base();
    }

    /************ module ************* */
    exitEntity_declaration(ctx) {
        let name = ctx.identifier();
        if (!name) {
            return null;
        }
        name = name[0].getText();
        let [...ports] = this.ports;
        let [...params] = this.params;
        this.curModule = {
            "includes"   : [],
            "languageId" : "vhdl",
            'moduleName' : name,
            'modulePath' : null,
            'ports'      : ports,
            'params'     : params,
            "instances"  : null,
            "start" : {
                line : ctx.start.line - 1,
                character : ctx.start.column,
            },
            "stop" : {
                line : ctx.stop.line - 1,
                character : ctx.stop.column,
            }
        };
        this.ports = [];
        this.params = [];
        this.modules.push(this.curModule);
    }

    enterEntity_header(ctx) {
        this.process_generic_info(ctx);
        this.process_port_info(ctx);
    }

    /************ params ************* */
    process_generic_info(ctx) {
        let params = [];

        // 123 : interface_constant_declaration
        this.base.child_recursive(ctx, 123, params);
        for (let i = 0; i < params.length; i++) {
            const param = params[i];
            let names = param.identifier_list();
            if (!names) {
                continue;
            }
            names = names.identifier();

            let expression = [];
            // 96 : expression
            this.base.child_recursive(param, 96, expression);
            for (let i = 0; i < names.length; i++) {
                const name = names[i];
                let item = {
                    "name" : name.getText(),
                    "paramName"  : name.getText(),
                    "paramInit"  : expression.length ? expression[0].getText() : null,
                }
                this.params.push(item); 
            }
        }
    }

    /************ ports ************* */
    process_port_info(ctx) {
        let ports = [];

        // 131 : interface_port_declaration
        this.base.child_recursive(ctx, 131, ports);
        for (let i = 0; i < ports.length; i++) {
            const port = ports[i];
            let names = port.identifier_list();
            if (!names) {
                continue;
            }
            names = names.identifier();

            let type = port.signal_mode();
            switch (type) {
                case 'in':
                case 'IN':
                    type = 'input';
                break;
                case 'out':
                case 'OUT':
                    type = 'output';
                break;
                case 'inout':
                case 'INOUT':
                    type = 'inout';
                break;
                default: type = null; break;
            }

            let width = [];
            this.base.child_recursive(port, 74, width);
            for (let i = 0; i < names.length; i++) {
                const name = names[i];
                let item = {
                    "type" : type,
                    "name" : name.getText(),
                    "portName" : name.getText(),
                    "portWidth": width.length ? width[0].getText() : null,
                }
                this.ports.push(item);
            }
        }
    }

    /************ instantiation ************* */
    enterComponent_instantiation_statement(ctx) {
        let name = ctx.label_colon();
        if (!name) {
            return null;
        }
        name = name.getText().replace(':', '');

        let module = ctx.instantiated_unit();
        if (!module) {
            return null;
        }
        module = module.getText().replace(':', '');

        let curInstance = {
            "name": name,
            "type": "instance",
            "instparams": this.process_generic_info(ctx),
            "instports" : this.process_port_range(ctx),
            "instName": name,         // name
            "instModule": module,   // module
            "instModPath": "",
        };

        curInstance.start = {
            line : ctx.start.line - 1,
            character : ctx.start.column,
        };
        curInstance.stop = {
            line : ctx.stop.line - 1,
            character : ctx.stop.column,
        };

        this.instances.push(curInstance);
    }

    process_generic_range(ctx) {
        let params = ctx.generic_map_aspect();
        if (!params) {
            return null;
        }

        return {
            start : {
                line : params.start.line - 1,
                character : params.start.column,
            },
            stop : {
                line : params.stop.line - 1,
                character : params.stop.column,
            }
        }
    }

    process_port_range(ctx) {
        let ports = ctx.port_map_aspect();
        if (!ports) {
            return null;
        }

        return {
            start : {
                line : ports.start.line - 1,
                character : ports.start.column,
            },
            stop : {
                line : ports.stop.line - 1,
                character : ports.stop.column,
            }
        }
    }
}

class fsmVisitor extends vhdlListener.vhdlListener {
    constructor () {
        super();
        this.base = new base();
    }

    
}

class visitor extends vhdlListener.vhdlListener {
    constructor(option) {
        super();
        this.option = option;
        
        this.curModule = null;
        this.curParent = null;

        this.base = new base();
    }

    enterEntity_declaration(ctx) {
        this.process_identifier(ctx, "entity");
    }

    enterComponent_declaration(ctx) {
        this.process_identifier(ctx, "component");
    }

    enterComponent_instantiation_statement(ctx) {
        let name = ctx.label_colon();
        if (!name) {
            return null;
        }
        name = name.getText().replace(':', '');
        let item = {
            'name' : name,
            'type' : "instance",
            'parent' : null,
            "start" : {
                line : ctx.start.line - 1,
                character : ctx.start.column,
            },
            "end" : {
                line : ctx.stop.line - 1,
                character : ctx.stop.column,
            }
        };
        if (this.option.symbol) {
            this.option.symbol.setSymbolInfo(item);
        }
    }
    
    enterInterface_constant_declaration(ctx) {
        this.process_identifier_list(ctx, "constant");
    }

    enterInterface_variable_declaration(ctx) {
        this.process_identifier_list(ctx, "variable");
    }

    enterInterface_port_declaration(ctx) {
        this.process_identifier_list(ctx, "port");
    }

    enterInterface_signal_declaration(ctx) {
        this.process_identifier_list(ctx, "signal");
    }

    enterInterface_quantity_declaration(ctx) {
        this.process_identifier_list(ctx, "quantity");
    }

    enterSignal_declaration(ctx) {
        this.process_identifier_list(ctx, "signal")
    }

    enterConstant_declaration(ctx) {
        this.process_identifier_list(ctx, "constant")
    }

    enterVariable_declaration(ctx) {
        this.process_identifier_list(ctx, "variable")
    }

    process_identifier_list(ctx, type) {
        let names = ctx.identifier_list();
        if (!names) {
            return null;
        }
        names = names.identifier();
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            let item = {
                'name' : name.getText(),
                'type' : type,
                'parent' : null,
                "start" : {
                    line : ctx.start.line - 1,
                    character : ctx.start.column,
                },
                "end" : {
                    line : ctx.stop.line - 1,
                    character : ctx.stop.column,
                }
            };
            if (this.option.symbol) {
                this.option.symbol.setSymbolInfo(item);
            }
        }
    }

    process_identifier(ctx, type) {
        let name = ctx.identifier();
        if (!name) {
            return null;
        }
        name = name[0].getText();
        let item = {
            'name' : name,
            'type' : type,
            'parent' : null,
            "start" : {
                line : ctx.start.line - 1,
                character : ctx.start.column,
            },
            "end" : {
                line : ctx.stop.line - 1,
                character : ctx.stop.column,
            }
        };
        if (this.option.symbol) {
            this.option.symbol.setSymbolInfo(item);
        }
    }
}

function parse(code) {
    const inputStream = new antlr4.InputStream(code);
    const lexer = new vhdlLexer.vhdlLexer(inputStream);

    lexer.removeErrorListeners();
    const errorListener = new vhdlErrorListener();
    lexer.addErrorListener(errorListener);

    const tokenStream = new antlr4.CommonTokenStream(lexer);
    const parser = new vhdlParser.vhdlParser(tokenStream);
    parser.removeErrorListeners();
    parser.addErrorListener(errorListener);

    const ast = parser.parse();
    const errors = errorListener.diags;

    return {
        stream : tokenStream, 
        ast : ast, 
        err : errors 
    };
}

function walk(ast, visit) {
    antlr4.tree.ParseTreeWalker.DEFAULT.walk(visit, ast);
    return visit;
}

class parser {

    constructor() {
        this.l_comment = /--.*/g;
        this.b_comment = /\/\*[\s\S]*?\*\//g;
    }

    lint(code) {
        const parseResult = parse(code);
        return parseResult.err;
    }

    /**
     * @state finshed - test
     * @descriptionCn 获取文件的详细属性
     * @param {Object} option   获取时需要操作的选项 
     * @param {Array}  HDLparam 在快解析模式下模块的详细属性存放的数组
     * @returns {Array}  HDLparam 
     */
    getFileParam(option, HDLparam) {
        try {
            // option是必须的
            if (!option) {
                return HDLparam;
            }
    
            const parseResult = parse(option.text);
            console.log(parseResult.err);
    
            // 仅定义为true时运行，null，false时均全运行
            if (option.isFast) { 
                var fastVisit = new fastVisitor();
                const walkResult = walk(parseResult.ast, fastVisit);
                
                for (let index = 0; index < walkResult.modules.length; index++) {
                    const module = walkResult.modules[index];
                    module.instances = walkResult.instances;
                    module.modulePath = option.path;
                    HDLparam.push(module);
                }
    
                return HDLparam;
            }
    
            var visit = new visitor(option);
            walk(parseResult.ast, visit);
        }
        catch (error) {
            console.log(error);
            return HDLparam;
        }
    }

    getFSMParam() {
        try {
            const parseResult = parse(option.text);
            var visit = new fsmVisitor();
            const walkResult = walk(parseResult.ast, visit);
        }
        catch (error) {
            console.log(error);
            return null;
        }
    }

    /**
     * @state finish - tested
     * @descriptionCn 将文本中的注释全部去掉
     * @descriptionEn delete all comment form verilog code
     * @param {String} text Verilog code input
     * @returns Verilog code output after deleting all comment content
     */
     del_comments(text) {
        let match = text.match(this.b_comment);
        if (match != null) {
            for (let i = 0; i < match.length; i++) {
                const element = match[i];
                const newElement = ' '.repeat(element.length);
                text = text.replace(element,newElement);
            }
        }
        match = text.match(this.l_comment);
        if (match != null) {
            for (let i = 0; i < match.length; i++) {
                const element = match[i];
                const newElement = ' '.repeat(element.length);
                text = text.replace(element,newElement);
            }
        }
        return text;
    }

    /**
     * @state finish - tested
     * @descriptionCn 获取Verilog代码中的注释范围
     * @param {String} text   Verilog代码文本
     * @param {Number} offset text文本在整个代码段中的偏移
     * @returns 由注释范围对象所组成的数组
     */
    get_comment_index(text, offset) {
        let commentIndex = [];
        let commentRegExps = [this.b_comment, this.l_comment];
        for (let i = 0; i < commentRegExps.length; i++) {
            while (1) {
                let match = commentRegExps[i].exec(text);
                if (match == null) {
                    break;
                }
                let index = {
                    "startIndex" : 0,
                    "lastIndex"  : 0
                }
                index.startIndex = match.index + offset ? offset : 0;
                index.lastIndex = match.index + match[0].length + offset ? offset : 0;
                commentIndex.push(index);
            }
        }
        return commentIndex;
    }
}
module.exports = parser;
