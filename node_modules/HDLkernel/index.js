var fs = require("fs");
var os = require('os');
var fspath = require("path");

var exec = require('child_process').execSync;
// init

var kernel = require("./kernel/kernel"); // in fact it is kernel

var virtualFileSystem = {
    module: null,

    /**
     * 显示指定文件夹下的所有子目录, 并返回
     * @param {*} path 所要显示的文件夹的绝对路径 (省略对应root的\)
     * @returns 返回所有子目录
     */
    showlist : function (path) {
        let lists = this.module.FS.readdir(`/${path}`);
        console.log(lists);
        return lists;
    },

    /**
     * 将本地路径挂载到虚拟文件系统下
     * @param {*} local   需要挂载的本地路径
     * @param {*} virtual 所要挂载到的虚拟文件系统的绝对路径 (省略对应root的/)
     */
    mount : function (local, virtual) {
        this.mkdir(virtual);
        this.module.FS.mount(this.module.NODEFS, { root: local }, `/${virtual}`);
    },

    diskMount : function () {
        var aDrives = [];
        var result = null;
        var stdout = null;
        switch (os.platform().toLowerCase()) {
            case 'win32':
                result = exec('wmic logicaldisk get Caption,FreeSpace,Size,VolumeSerialNumber,Description  /format:list');
                stdout = result.toString();
                var aLines = stdout.split('\r\r\n');
                var bNew = false;
                var sCaption = '', sDescription = '', sFreeSpace = '', sSize = '', sVolume = '';
                // For each line get information
                // Format is Key=Value
                for(var i = 0; i < aLines.length; i++) {
                    if (aLines[i] != '') {
                        var aTokens = aLines[i].split('=');
                        switch  (aTokens[0]) {
                            case 'Caption':											
                                sCaption = aTokens[1];
                                bNew = true;
                                break;
                            case 'Description':									
                                sDescription = aTokens[1];									
                                break;
                            case 'FreeSpace':
                                sFreeSpace = aTokens[1];
                                break;
                            case 'Size':
                                sSize = aTokens[1];
                                break;
                            case 'VolumeSerialNumber':
                                sVolume = aTokens[1];
                                break;
                        }
                    
                    } else {
                        // Empty line 
                        // If we get an empty line and bNew is true then we have retrieved
                        // all information for one drive, add to array and reset variables
                        if (bNew) {								
                            sSize = parseFloat(sSize);
                            if (isNaN(sSize)) {
                                sSize = 0;
                            }
                            sFreeSpace = parseFloat(sFreeSpace);
                            if (isNaN(sFreeSpace)) {
                                sFreeSpace = 0;
                            }
                            
                            var sUsed = (sSize - sFreeSpace);
                            var sPercent = '0%';
                            if (sSize != '' && parseFloat(sSize) > 0) {
                                sPercent = Math.round((parseFloat(sUsed) / parseFloat(sSize)) * 100) + '%';
                            }
                            aDrives[aDrives.length] = {
                                filesystem:	sDescription,
                                blocks:		sSize,
                                used:		sUsed,
                                available:	sFreeSpace,
                                capacity:	sPercent,
                                mounted:	sCaption
                            };
                            bNew = false;
                            sCaption = ''; 
                            sDescription = ''; 
                            sFreeSpace = ''; 
                            sSize = ''; 
                            sVolume = '';
                        }
                    
                    }
                }
                for (var i = 0; i < aDrives.length; i++) {
                    let diskName = aDrives[i].mounted.toLowerCase();
                    console.log(diskName);
                    this.mount(diskName, diskName);
                }
            break;
            default:
                this.mount('/', 'host');
            break;
        }
    },

    /**
     * 虚拟文件系统下创建文件夹
     * @param {*} path 虚拟文件系统内部的绝对路径 (省略对应root的\)
     * 可越级创建，会自动生成父级文件夹
     */
    mkdir : function (path) {
        if (this.module.FS.findObject(`/${path}`) != null) {
            return true;
        } else {
            let dirname = fspath.dirname(path);
            if (dirname == path) {
                this.module.FS.mkdir(`/${path}`);
                return true;
            }
            if (this.mkdir(dirname)) {
                this.module.FS.mkdir(`/${path}`);
            }
            return true;
        }
    },

    /**
     * 删除虚拟文件系统下的文件夹
     * @param {*} path 虚拟文件系统内部的绝对路径 (省略对应root的\)
     * 可越级创建，会自动删除父级文件夹
     */
    rmdir : function (path) {
        let files = [];
        if (this.module.FS.findObject(`/${path}`) != null) {
            files = this.module.FS.readdir(`/${path}`);
            for (let index = 2; index < files.length; index++) {
                const element = files[index];
                let curPath = fspath.join(`/${path}`, element).replace(/\\/g, "\/");
                let value = this.module.FS.isDir(this.module.FS.stat(curPath).mode);
                if (value) {
                    this.rmdir(curPath);
                } else {
                    this.module.FS.unlink(curPath);
                }
            }
            this.module.FS.rmdir(`/${path}`); //清除文件夹
        }
    },

    /**
     * 删除虚拟文件系统下的指定文件
     * @param {*} path 虚拟文件系统内部的绝对路径 (省略对应root的\)
     */
    rmfile : function (path) {
        this.module.FS.unlink(`/${path}`);
    },

    /**
     * 将本地路径下的文件写入虚拟文件系统
     * @param {*} src 文件的本地的绝对路径
     * @param {*} des 虚拟文件系统内部指定地址 (省略对应root的\)
     * 可越级创建，会自动生成父级文件夹
     */
    writeFileFormPath : function (src, des) {
        let desDir = fspath.dirname(des);
        let content = fs.readFileSync(src, "utf-8");
        if (this.module.FS.findObject(`/${desDir}`) != null) {
            this.module.FS.writeFile(`/${des}`, content, { encoding: 'utf8' });
        } else {
            this.mkdir(`/${desDir}`);
            this.module.FS.writeFile(`/${des}`, content, { encoding: 'utf8' });
        }
    },

    /**
     * 将文件内容写入虚拟文件系统
     * @param {*} text 要写入的文件内容
     * @param {*} path 虚拟文件系统内部指定地址 (省略对应root的\)
     * 可越级创建，会自动生成父级文件夹
     */
     writeFileFormText : function (text, path) {
        let pathDir = fspath.dirname(path);
        if (this.module.FS.findObject(`/${pathDir}`) != null) {
            this.module.FS.writeFile(`/${path}`, text, { encoding: 'utf8' });
        } else {
            this.mkdir(`/${pathDir}`);
            this.module.FS.writeFile(`/${path}`, text, { encoding: 'utf8' });
        }
    },

    /**
     * 从虚拟文件系统中读出文件到本地
     * @param {*} src 虚拟文件系统内部指定地址 (省略对应root的\)
     * @param {*} des 要写到的本地文件的绝对路径
     */
    readFileToPath : function (src, des) {
        if (this.module.FS.findObject(`/${src}`) != null) {
            let content = this.module.FS.readFile(`/${src}`, { encoding: 'utf8' });
            fs.writeFileSync(des, content, "utf-8");
        } else {
            console.log(`ERROR: The ${src} is not at this virtual system.`);
        }
    },

    /**
     * 从虚拟文件系统中读出文件内容
     * @param {*} path 虚拟文件系统内部指定地址 (省略对应root的\)
     * @returns 读出文件的内容
     */
    readFileToText : function (path) {
        if (this.module.FS.findObject(`/${path}`) != null) {
            let content = this.module.FS.readFile(`/${path}`, { encoding: 'utf8' });
            return content;
        } else {
            console.log(`ERROR: The ${path} is not at this virtual system.`);
        }
    },
}
exports.virtualFileSystem = virtualFileSystem;

var kernelOperation = {
    module: null,

    cmd : [
        // Before Behavioral Synth
        "design -reset-vlog; proc; write_json /output.json",
        // After Behavioral Synth
        "design -reset-vlog; proc; opt_clean; write_json /output.json",
        // After RTL Synth
        "synth -run coarse; write_json /output.json",
    ],

    exec : function (command) {
        this.module.ccall('run', '', ['string'], [command]);
    },

    printHelp : function () {
        this.module.TTY.message = '';
        this.exec("help");
        return this.module.TTY.message;
    },

    /**
     * 设置内置log输出的使能 true : 打开内置log输出 false : 关闭内置log输出
     * @param {*} params true | false
     */
    setInnerOutput : function (params) {
        this.module.TTY.innerOutput = params;
    },

    /**
     * 设置message的回调函数
     * @param {*} operation 对message操作的回调函数
     */
    setMessageCallback : function (operation) {
        this.module.TTY.innerOutput = false;
        this.module.TTY.callbackOutput = true;
        this.module.TTY.callback = operation;
    },

    /**
     * 导入文件到工程之中(仅适用于nodefs) 默认支持sv且覆盖
     * @param {*} verilogFiles 数组形式输入 输入所需导入工程的文件数组
     * @returns 导入过程中所输出的日志(仅适用与message回调关闭的时候)
     */
    loadFile : function (verilogFiles) {
        this.module.TTY.message = "";
        for (let index = 0; index < verilogFiles.length; index++) {
            let verilogFile = verilogFiles[index];
            switch (os.platform().toLowerCase()) {
                case 'win32': 
                    this.exec(`read_verilog -sv -formal -overwrite /${verilogFile}`);
                break;
                default :
                    this.exec(`read_verilog -sv -formal -overwrite /host/${verilogFile}`);
                break;
            }
        }
        return this.module.TTY.message;
    },

    /**
     * 综合并导出 工程的json文件
     * @param {*} mode 在导出json之前需要进行的处理类型
     * @returns json对象
     */
    exportJson : function (mode, isSpecified) {
        let execMode = parseInt(mode);
        let command = this.cmd[execMode];
        if (execMode == 2) {
            if (isSpecified) {
                switch (isSpecified) {
                    case "xilinx":
                        command = `synth_xilinx; write_json /output.json`
                    break;
                
                    default: break;
                }
            }
        }
        this.exec(command);
        let jsonStr = virtualFileSystem.readFileToText('output.json');
        return JSON.parse(jsonStr);
    },

    /**
     * xilinx FPGA 结构综合
     * @param {*} topModule 顶层模块名
     * @param {*} family    器件类型  
     * @param {*} edif_path 导出 edif 文件地址
     * @param {*} blif_path 导出 blif 文件地址
     * @param {*} arg       自定义参数
     */
    synthXilinx(topModule, family, edif_path, blif_path, arg) {
        let command = `synth_xilinx -top ${topModule}`;
        
        if (family != undefined) {
            command = command + ` -family ${family}`;
        }
        if (edif_path != undefined) {
            command = command + ` -edif /${topModule}.edif`;
        }
        if (blif_path != undefined) {
            command = command + ` -blif /${topModule}.blif`;
        }
        if (arg != undefined) {
            command = command + arg;
        }
        this.module.ccall('run', '', ['string'], [command]);
        if (edif_path != undefined) {
            fs.writeFileSync(edif_path, 
                virtualFileSystem.readFileToText(`${topModule}.edif`), 
                "utf-8");
            virtualFileSystem.rmfile(`${topModule}.edif`);
        }
        if (blif_path != undefined) {
            fs.writeFileSync(blif_path, 
                virtualFileSystem.readFileToText(`${topModule}.blif`), 
                "utf-8");
            virtualFileSystem.rmfile(`${topModule}.blif`);
        }
    }
}
exports.kernelOperation = kernelOperation;

async function launch() {
    // 例化核心
    let module = await kernel();

    // 将核心导入到操作系统虚拟文件系统
    kernelOperation.module = module;
    virtualFileSystem.module = module;

    // 本地磁盘挂载
    virtualFileSystem.diskMount();
    
    // 导出内核
    return {
        vfs : virtualFileSystem,
        ope : kernelOperation,
    };
}
exports.launch = launch;
