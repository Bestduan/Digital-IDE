var fs     = require("fs");
var fspath = require("path");
// init

var kernel = require("./kernel/kernel"); // in fact it is kernel
var vlog_include = new RegExp([
    /`include\s*?/,
    /[\"\']\s*?(?<path>.+)\s*?[\"\']/,
].map(x => (typeof x === 'string') ? x : x.source).join(''), 'mg');

var virtualFileSystem = {
    module: null,

    /**
     * 显示指定文件夹下的所有子目录, 并返回
     * @param {*} path 所要显示的文件夹的绝对路径 (省略对应root的\)
     * @returns 返回所有子目录
     */
    showlist : function (path) {
        let lists = this.module.FS.readdir(`/${path}`);
        console.log(lists);
        return lists;
    },

    /**
     * 将本地路径挂载到虚拟文件系统下
     * @param {*} local   需要挂载的本地路径
     * @param {*} virtual 所要挂载到的虚拟文件系统的绝对路径 (省略对应root的\)
     */
    mount : function (local, virtual) {
        this.mkdir(virtual);
        this.module.FS.mount(this.module.NODEFS, { root: local }, `/${virtual}`);
    },

    /**
     * 虚拟文件系统下创建文件夹
     * @param {*} path 虚拟文件系统内部的绝对路径 (省略对应root的\)
     * 可越级创建，会自动生成父级文件夹
     */
    mkdir : function (path) {
        if (this.module.FS.findObject(`/${path}`) != null) {
            return true;
        } else {
            if (this.mkdir(fspath.dirname(path))) {
                this.module.FS.mkdir(`/${path}`);
            }
            return true;
        }
    },

    /**
     * 删除虚拟文件系统下的文件夹
     * @param {*} path 虚拟文件系统内部的绝对路径 (省略对应root的\)
     * 可越级创建，会自动删除父级文件夹
     */
    rmdir : function (path) {
        let files = [];
        if (this.module.FS.findObject(`/${path}`) != null) {
            files = this.module.FS.readdir(`/${path}`);
            for (let index = 2; index < files.length; index++) {
                const element = files[index];
                let curPath = fspath.join(`/${path}`, element).replace(/\\/g, "\/");
                let value = this.module.FS.isDir(this.module.FS.stat(curPath).mode);
                if (value) {
                    this.rmdir(curPath);
                } else {
                    this.module.FS.unlink(curPath);
                }
            }
            this.module.FS.rmdir(`/${path}`); //清除文件夹
        }
    },

    /**
     * 删除虚拟文件系统下的指定文件
     * @param {*} path 虚拟文件系统内部的绝对路径 (省略对应root的\)
     */
    rmfile : function (path) {
        this.module.FS.unlink(`/${path}`);
    },

    /**
     * 将本地路径下的文件写入虚拟文件系统
     * @param {*} src 文件的本地的绝对路径
     * @param {*} des 虚拟文件系统内部指定地址 (省略对应root的\)
     * 可越级创建，会自动生成父级文件夹
     */
    writeFileFormPath : function (src, des) {
        let desDir = fspath.dirname(des);
        let content = fs.readFileSync(src, "utf-8");
        if (this.module.FS.findObject(`/${desDir}`) != null) {
            this.module.FS.writeFile(`/${des}`, content, { encoding: 'utf8' });
        } else {
            this.mkdir(`/${desDir}`);
            this.module.FS.writeFile(`/${des}`, content, { encoding: 'utf8' });
        }
    },

    /**
     * 将文件内容写入虚拟文件系统
     * @param {*} text 要写入的文件内容
     * @param {*} path 虚拟文件系统内部指定地址 (省略对应root的\)
     * 可越级创建，会自动生成父级文件夹
     */
     writeFileFormText : function (text, path) {
        let pathDir = fspath.dirname(path);
        if (this.module.FS.findObject(`/${pathDir}`) != null) {
            this.module.FS.writeFile(`/${path}`, text, { encoding: 'utf8' });
        } else {
            this.mkdir(`/${pathDir}`);
            this.module.FS.writeFile(`/${path}`, text, { encoding: 'utf8' });
        }
    },

    /**
     * 从虚拟文件系统中读出文件到本地
     * @param {*} src 虚拟文件系统内部指定地址 (省略对应root的\)
     * @param {*} des 要写到的本地文件的绝对路径
     */
    readFileToPath : function (src, des) {
        if (this.module.FS.findObject(`/${src}`) != null) {
            let content = this.module.FS.readFile(`/${src}`, { encoding: 'utf8' });
            fs.writeFileSync(des, content, "utf-8");
        } else {
            console.log(`ERROR: The ${src} is not at this virtual system.`);
        }
    },

    /**
     * 从虚拟文件系统中读出文件内容
     * @param {*} path 虚拟文件系统内部指定地址 (省略对应root的\)
     * @returns 读出文件的内容
     */
    readFileToText : function (path) {
        if (this.module.FS.findObject(`/${path}`) != null) {
            let content = this.module.FS.readFile(`/${path}`, { encoding: 'utf8' });
            return content;
        } else {
            console.log(`ERROR: The ${path} is not at this virtual system.`);
        }
    },
}
exports.virtualFileSystem = virtualFileSystem;

var kernelOperation = {
    module: null,

    cmd : [
        // Before Behavioral Synth
        "design -reset-vlog; proc; write_json /output.json",
        // After Behavioral Synth
        "design -reset-vlog; proc; opt_clean; write_json /output.json",
        // After RTL Synth
        "synth -run coarse; write_json /output.json",
    ],

    exec : function (command) {
        this.module.ccall('run', '', ['string'], [command]);
    },

    printHelp : function () {
        this.module.TTY.message = '';
        this.exec("help");
        return this.module.TTY.message;
    },

    /**
     * 设置内置log输出的使能 true : 打开内置log输出 false : 关闭内置log输出
     * @param {*} params true | false
     */
    setInnerOutput : function (params) {
        this.module.TTY.innerOutput = params;
    },

    /**
     * 设置message的回调函数
     * @param {*} operation 对message操作的回调函数
     */
    setMessageCallback : function (operation) {
        this.module.TTY.innerOutput = false;
        this.module.TTY.callbackOutput = true;
        this.module.TTY.callback = operation;
    },

    /**
     * 直接导入文件到工程之中
     * @param {*} verilogFiles 数组形式输入 输入所需导入工程的文件数组
     * @returns 导入过程中所输出的日志(仅适用与message回调关闭的时候)
     */
    loadFileDirect : function (verilogFiles) {
        this.module.TTY.message = "";
        for (let index = 0; index < verilogFiles.length; index++) {
            let verilogFile = verilogFiles[index];
            let text = fs.readFileSync(verilogFile, "utf-8");
            text = text.replace(vlog_include, '');
            virtualFileSystem.writeFileFormText(text, "dist/verilog.sv");
            this.exec(`read_verilog -sv /dist/verilog.sv`);
        }
        return this.module.TTY.message;
    },

    /**
     * 导入文件到工程之中, 导入之后随机删除在虚拟文件系统中导入的文件
     * @param {*} verilogFiles 数组形式输入 输入所需导入工程的文件数组
     * @returns 导入过程中所输出的日志(仅适用与message回调关闭的时候)
     */
     loadFileFromPath : function (verilogFiles) {
        this.module.TTY.message = "";
        for (let index = 0; index < verilogFiles.length; index++) {
            let verilogFile = verilogFiles[index];
            if (fs.existsSync(verilogFile)) {
                virtualFileSystem.writeFileFormPath(verilogFile, verilogFile);
                this.exec(`read_verilog /${verilogFile}`);
                virtualFileSystem.rmfile(verilogFile);
            }
        }
        return this.module.TTY.message;
    },

    /**
     * 导入文件到工程之中(仅适用于nodefs)
     * @param {*} verilogFiles 数组形式输入 输入所需导入工程的文件数组
     * @param {*} parent 需要忽视的父级目录
     * @returns 导入过程中所输出的日志(仅适用与message回调关闭的时候)
     */
    loadFile : function (verilogFiles, parent) {
        this.module.TTY.message = "";
        for (let index = 0; index < verilogFiles.length; index++) {
            let verilogFile = verilogFiles[index];
            let verilogFilePath = verilogFile.replace(parent, "/project");
            this.exec(`read_verilog /${verilogFilePath}`);
        }
        return this.module.TTY.message;
    },

    /**
     * 综合并导出 工程的json文件
     * @param {*} mode 在导出json之前需要进行的处理类型
     * @returns json对象
     */
    exportJson : function (mode, isSpecified) {
        let execMode = parseInt(mode);
        let command = this.cmd[execMode];
        if (execMode == 2) {
            if (isSpecified) {
                switch (isSpecified) {
                    case "xilinx":
                        command = `synth_xilinx; write_json /output.json`
                    break;
                
                    default: break;
                }
            }
        }
        this.exec(command);
        let jsonStr = virtualFileSystem.readFileToText('output.json');
        return JSON.parse(jsonStr);
    },

    /**
     * xilinx FPGA 结构综合
     * @param {*} topModule 顶层模块名
     * @param {*} family    器件类型  
     * @param {*} edif_path 导出 edif 文件地址
     * @param {*} blif_path 导出 blif 文件地址
     * @param {*} arg       自定义参数
     */
    synthXilinx(topModule, family, edif_path, blif_path, arg) {
        let command = `synth_xilinx -top ${topModule}`;
        
        if (family != undefined) {
            command = command + ` -family ${family}`;
        }
        if (edif_path != undefined) {
            command = command + ` -edif /${topModule}.edif`;
        }
        if (blif_path != undefined) {
            command = command + ` -blif /${topModule}.blif`;
        }
        if (arg != undefined) {
            command = command + arg;
        }
        this.module.ccall('run', '', ['string'], [command]);
        if (edif_path != undefined) {
            fs.writeFileSync(edif_path, 
                virtualFileSystem.readFileToText(`${topModule}.edif`), 
                "utf-8");
            virtualFileSystem.rmfile(`${topModule}.edif`);
        }
        if (blif_path != undefined) {
            fs.writeFileSync(blif_path, 
                virtualFileSystem.readFileToText(`${topModule}.blif`), 
                "utf-8");
            virtualFileSystem.rmfile(`${topModule}.blif`);
        }
    }
}
exports.kernelOperation = kernelOperation;

async function launch() {
    // 例化核心
    let module = await kernel();

    // 将核心导入到操作系统虚拟文件系统
    kernelOperation.module   = module;
    virtualFileSystem.module = module;
    
    // 导出内核
    return {
        vfs : virtualFileSystem,
        ope : kernelOperation,
    };
}
exports.launch = launch;


/**
 * kernel 测试代码
 */
// launch().then((kernel) => {
//     let test_list = [
//         "D:/project/FPGA/FPGA_Design/TCL_project/Test/DIDE_test/user/src/Verilog/fsm_test.v"
//     ];
//     let log = kernel.ope.printHelp();
//     console.log(log);

//     kernel.ope.loadFileDirect(test_list);
//     kernel.ope.exec("")
// });