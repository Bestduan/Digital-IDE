{
"count": {
	"prefix": "count",
	"body": [
        "//define the time counter",
        "reg [${1:32}:0]      cnt$2 = 0;",
        "reg             ${3:impulse};",
        "parameter       SET_TIME = $1'd$4;",
        "always@(posedge clk) begin",
        "    if (cnt$2 == SET_TIME) begin",
        "        cnt$2 <= $1'd0;",
        "        $3 <= 1'd1;",
        "    end",
        "    else begin",
        "        cnt$2 <= cnt$2 + 1'd1;",
        "        $3 <= 1'd0;",
        "    end",
        "end"
	]
},

"clk_div": {
	"prefix": "div",
	"body": [
        "reg [${1:3}:0]      cnt$2 = 0;",
        "reg                 clk_div$2;",
        "always@(posedge ${3:clk}) begin",
        "    if (cnt$2 == ${4:3}) begin",
        "        cnt$2 <= $1'd0;",
        "        clk_div$2 <= ~clk_div$2;",
        "    end",
        "    else begin",
        "        cnt$2 <= cnt$2 + 1'd1;",
        "    end",
        "end"
	]
},

"lock": {
	"prefix": "lock",
	"body": [
        "reg  gate$2;",
        "reg  gate$2_buf;",

        "wire gate$2_pose =  gate$2 & ~gate$2_buf;",
        "wire gate$2_nege =  ~gate$2 & gate$2_buf;",

        "always@(posedge clk) begin",
        "   gate$2 <= ${1:signal};",
        "   gate$2_buf <= gate$2;",
        "end"
	]
},

"state": {
	"prefix": "state",
	"body": [
        "reg [${1:4}:0] state;",
        "always@(posedge clk or negedge rst_n) begin",
        "   if(!rst_n) begin",
        "       state <= ${2:5}'d0;$3",
        "    end",
        "    else begin",
        "        case(state)",
        "            $2'd0:begin if(start_sig)begin state<=state+1; end end",
        "            $2'd1:begin $4; state<=state+1; end",
        "            $2'd2:begin $5; state<=state+1; end",
        "            $2'd3:begin $6; state<=state+1; end",
        "            $2'd4:begin $7; state<=state+1; end",
        "            $2'd5:begin $8; state<=state+1; end",
        "            $2'd6:begin $9; state<=state+1; end",
        "            $2'd7:begin $10; state<=state+1; end",
        "            $2'd8:begin $11; state<=state+1; end",
        "            default : begin state <= 0; end",
        "        endcase",
        "    end",
        "end"
	]
},

"initial": {
	"prefix": "initial",
	"body": [
        "initial begin",
        "   \\$dumpfile(\"wave.vcd\");",
        "   \\$dumpvars(0, testbench);",                     
        "   #6000 \\$finish;",                      
        "end"
	]
},

"generate_for": {
	"prefix": "generate",
	"body": [
        "genvar ${1:i};",
        "generate for($1 = 0 ; $1 < $2; $1 = $1 + 1) begin : ${3:U}",
        "\t$4",
        "end",
        "endgenerate"
	]
},

"generate_if": {
	"prefix": "generate",
	"body": [
        "generate if(${1:conditional}) begin : ${2:U}",
        "\t${3:}",
        "end",
        "endgenerate"
	]
},

"generate_case": {
	"prefix": "generate",
	"body": [
        "generate",
        "case (${1:NUM})",
        "32'd1 : begin : ${2:case1_name}",
        "$3",
        "        end",
        "32'd2 : begin : ${4:case1_name}",
        "$5",
        "        end",
        "default : begin : NOP end",
        "endcase",
        "endgenerate"
	]
},

"debug": {
	"prefix": "debug",
	"body": ["(* mark_debug = \"true\" *)"]
},

"time": {
	"prefix": "time",
	"body": ["`timescale 1ns / 1ps"]
},

"assign": {
	"prefix": "assign",
	"body": ["assign $1 = $2;"]
},

"initial param": {
	"prefix": "initial",
	"body": [
        "integer ${1:i};",
        "initial begin",
        "   for ($1 = 0; $1<${2:range}; $1=$1+1) begin",
        "        ${3:data}[$1] = 0;",
        "    end",   
        "end"
	]
},

"module": {
	"prefix": "module",
	"body": [
        "module ${1:name} #(",
        "    parameter    INPUT_WIDTH  = ${2:12},",
        "    parameter    OUTPUT_WIDTH = $2",
        ") (",
        "    input                           clk,",
        "    input                           rst_n,",
        "    input  [INPUT_WIDTH - 1 : 0]    ${3:data_i},",
        "    output [OUTPUT_WIDTH - 1 : 0]   ${4:data_o}",
        ");",
        "\t$5",
        "endmodule  //$1"
	]
},

"always": {
	"prefix": "always",
	"body": [
		"always @(*) begin",
		"\t$1",
		"end"
	],
	"description": "always @(*)"
},

"alwaysposclk": {
	"prefix": "alclk",
	"body": [
		"always @(posedge clk $1) begin",
		"\t$2",
		"end"
	],
	"description": "always @(posedge clk)"
},

"beginend": {
	"prefix": "beginend",
	"body": [
		"begin",
		"\t$1",
		"end"
	],
	"description": "begin ... end"
},

"case": {
	"prefix": "case",
	"body": [
		"case ($1)",
		"\t$2: $3",
		"\tdefault: $4",
		"endcase"
	],
	"description": "case () ... endcase"
},

"reg": {
	"prefix": "reg",
	"body": [
		"reg $1;"
	],
	"description": "reg reg_name;"
},

"regarray": {
	"prefix": "rega",
	"body": [
		"reg [$1:$2] $3;"
	],
	"description": "reg [N:0] reg_name;"
},

"regmemory": {
	"prefix": "regm",
	"body": [
		"reg [$1:$2] $3 [$4:$5];"
	],
	"description": "reg [N:0] reg_name [0:M];"
},

"wire": {
	"prefix": "wire",
	"body": [
		"wire $1;"
	],
	"description": "wire wire_name;"
},

"wirearray": {
	"prefix": "wirea",
	"body": [
		"wire [$1:$2] $3;"
	],
	"description": "wire [N:0] wire_name;"
},

"include": {
	"prefix": "inc",
	"body": [
		"`include \"$1\""
	],
	"description": "`include \"..\""
},

"define": {
	"prefix": "def",
	"body": [
		"`define $1 = $2"
	],
	"description": "`define var = val"
},

"parameter": {
	"prefix": "param",
	"body": [
		"parameter $1 = $2"
	],
	"description": "paramter var = val;"
},

"ternary": {
	"prefix": "ter",
	"body": [
		"$1 ? $2 : $3"
	],
	"description": "a ? b : c"
},

"if": {
	"prefix": "if",
	"body": [
		"if(${1:conditional}) begin",
        "    ${2:} <= ${3:};",
        "end"
	]
},

"else": {
	"prefix": "else",
	"body": [
		"else begin",
        "    $1 <= $2;",
        "end"
	]
},

"else_if": {
	"prefix": "else",
	"body": [
		"else if(${1:conditional}) begin",
        "    $2 <= $3;",
        "end"
	]
},

"for loop": {
	"prefix": "for",
	"body": [
		"integer ${1:i} = 0;",
		"for ($1 = 0; $1 < $2; $1 = $1 + 1) begin",
		"\t$3",
		"end"
	],
	"description": "for (...) begin ... end"
},

"while loop": {
	"prefix": "while",
	"body": [
		"while ($1) begin",
		"\t$2",
		"end"
	],
	"description": "while (...) begin ... end"
},

"function": {
	"prefix": "func",
	"body": [
		"function $1;",
		"\t$2;",
		"\t$3",
		"endfunction"
	],
	"description": "function (...) ... endfunction"
}
}
